// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: executor.proto

#ifndef PROTOBUF_executor_2eproto__INCLUDED
#define PROTOBUF_executor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "expression.pb.h"
#include "schema.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_executor_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsExecutorImpl();
void InitDefaultsExecutor();
void InitDefaultsTableScanImpl();
void InitDefaultsTableScan();
void InitDefaultsIndexScanImpl();
void InitDefaultsIndexScan();
void InitDefaultsSelectionImpl();
void InitDefaultsSelection();
void InitDefaultsProjectionImpl();
void InitDefaultsProjection();
void InitDefaultsAggregationImpl();
void InitDefaultsAggregation();
void InitDefaultsTopNImpl();
void InitDefaultsTopN();
void InitDefaultsLimitImpl();
void InitDefaultsLimit();
void InitDefaultsExecutorExecutionSummaryImpl();
void InitDefaultsExecutorExecutionSummary();
inline void InitDefaults() {
  InitDefaultsExecutor();
  InitDefaultsTableScan();
  InitDefaultsIndexScan();
  InitDefaultsSelection();
  InitDefaultsProjection();
  InitDefaultsAggregation();
  InitDefaultsTopN();
  InitDefaultsLimit();
  InitDefaultsExecutorExecutionSummary();
}
}  // namespace protobuf_executor_2eproto
namespace tipb {
class Aggregation;
class AggregationDefaultTypeInternal;
extern AggregationDefaultTypeInternal _Aggregation_default_instance_;
class Executor;
class ExecutorDefaultTypeInternal;
extern ExecutorDefaultTypeInternal _Executor_default_instance_;
class ExecutorExecutionSummary;
class ExecutorExecutionSummaryDefaultTypeInternal;
extern ExecutorExecutionSummaryDefaultTypeInternal _ExecutorExecutionSummary_default_instance_;
class IndexScan;
class IndexScanDefaultTypeInternal;
extern IndexScanDefaultTypeInternal _IndexScan_default_instance_;
class Limit;
class LimitDefaultTypeInternal;
extern LimitDefaultTypeInternal _Limit_default_instance_;
class Projection;
class ProjectionDefaultTypeInternal;
extern ProjectionDefaultTypeInternal _Projection_default_instance_;
class Selection;
class SelectionDefaultTypeInternal;
extern SelectionDefaultTypeInternal _Selection_default_instance_;
class TableScan;
class TableScanDefaultTypeInternal;
extern TableScanDefaultTypeInternal _TableScan_default_instance_;
class TopN;
class TopNDefaultTypeInternal;
extern TopNDefaultTypeInternal _TopN_default_instance_;
}  // namespace tipb
namespace tipb {

enum ExecType {
  TypeTableScan = 0,
  TypeIndexScan = 1,
  TypeSelection = 2,
  TypeAggregation = 3,
  TypeTopN = 4,
  TypeLimit = 5,
  TypeStreamAgg = 6
};
bool ExecType_IsValid(int value);
const ExecType ExecType_MIN = TypeTableScan;
const ExecType ExecType_MAX = TypeStreamAgg;
const int ExecType_ARRAYSIZE = ExecType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecType_descriptor();
inline const ::std::string& ExecType_Name(ExecType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecType_descriptor(), value);
}
inline bool ExecType_Parse(
    const ::std::string& name, ExecType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecType>(
    ExecType_descriptor(), name, value);
}
// ===================================================================

class Executor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.Executor) */ {
 public:
  Executor();
  virtual ~Executor();

  Executor(const Executor& from);

  inline Executor& operator=(const Executor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Executor(Executor&& from) noexcept
    : Executor() {
    *this = ::std::move(from);
  }

  inline Executor& operator=(Executor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Executor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Executor* internal_default_instance() {
    return reinterpret_cast<const Executor*>(
               &_Executor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Executor* other);
  friend void swap(Executor& a, Executor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Executor* New() const PROTOBUF_FINAL { return New(NULL); }

  Executor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Executor& from);
  void MergeFrom(const Executor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Executor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tipb.TableScan tbl_scan = 2;
  bool has_tbl_scan() const;
  void clear_tbl_scan();
  static const int kTblScanFieldNumber = 2;
  const ::tipb::TableScan& tbl_scan() const;
  ::tipb::TableScan* release_tbl_scan();
  ::tipb::TableScan* mutable_tbl_scan();
  void set_allocated_tbl_scan(::tipb::TableScan* tbl_scan);

  // optional .tipb.IndexScan idx_scan = 3;
  bool has_idx_scan() const;
  void clear_idx_scan();
  static const int kIdxScanFieldNumber = 3;
  const ::tipb::IndexScan& idx_scan() const;
  ::tipb::IndexScan* release_idx_scan();
  ::tipb::IndexScan* mutable_idx_scan();
  void set_allocated_idx_scan(::tipb::IndexScan* idx_scan);

  // optional .tipb.Selection selection = 4;
  bool has_selection() const;
  void clear_selection();
  static const int kSelectionFieldNumber = 4;
  const ::tipb::Selection& selection() const;
  ::tipb::Selection* release_selection();
  ::tipb::Selection* mutable_selection();
  void set_allocated_selection(::tipb::Selection* selection);

  // optional .tipb.Aggregation aggregation = 5;
  bool has_aggregation() const;
  void clear_aggregation();
  static const int kAggregationFieldNumber = 5;
  const ::tipb::Aggregation& aggregation() const;
  ::tipb::Aggregation* release_aggregation();
  ::tipb::Aggregation* mutable_aggregation();
  void set_allocated_aggregation(::tipb::Aggregation* aggregation);

  // optional .tipb.TopN topN = 6;
  bool has_topn() const;
  void clear_topn();
  static const int kTopNFieldNumber = 6;
  const ::tipb::TopN& topn() const;
  ::tipb::TopN* release_topn();
  ::tipb::TopN* mutable_topn();
  void set_allocated_topn(::tipb::TopN* topn);

  // optional .tipb.Limit limit = 7;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 7;
  const ::tipb::Limit& limit() const;
  ::tipb::Limit* release_limit();
  ::tipb::Limit* mutable_limit();
  void set_allocated_limit(::tipb::Limit* limit);

  // optional .tipb.Aggregation stream_agg = 8;
  bool has_stream_agg() const;
  void clear_stream_agg();
  static const int kStreamAggFieldNumber = 8;
  const ::tipb::Aggregation& stream_agg() const;
  ::tipb::Aggregation* release_stream_agg();
  ::tipb::Aggregation* mutable_stream_agg();
  void set_allocated_stream_agg(::tipb::Aggregation* stream_agg);

  // optional .tipb.ExecType tp = 1;
  bool has_tp() const;
  void clear_tp();
  static const int kTpFieldNumber = 1;
  ::tipb::ExecType tp() const;
  void set_tp(::tipb::ExecType value);

  // @@protoc_insertion_point(class_scope:tipb.Executor)
 private:
  void set_has_tp();
  void clear_has_tp();
  void set_has_tbl_scan();
  void clear_has_tbl_scan();
  void set_has_idx_scan();
  void clear_has_idx_scan();
  void set_has_selection();
  void clear_has_selection();
  void set_has_aggregation();
  void clear_has_aggregation();
  void set_has_topn();
  void clear_has_topn();
  void set_has_limit();
  void clear_has_limit();
  void set_has_stream_agg();
  void clear_has_stream_agg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::tipb::TableScan* tbl_scan_;
  ::tipb::IndexScan* idx_scan_;
  ::tipb::Selection* selection_;
  ::tipb::Aggregation* aggregation_;
  ::tipb::TopN* topn_;
  ::tipb::Limit* limit_;
  ::tipb::Aggregation* stream_agg_;
  int tp_;
  friend struct ::protobuf_executor_2eproto::TableStruct;
  friend void ::protobuf_executor_2eproto::InitDefaultsExecutorImpl();
};
// -------------------------------------------------------------------

class TableScan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.TableScan) */ {
 public:
  TableScan();
  virtual ~TableScan();

  TableScan(const TableScan& from);

  inline TableScan& operator=(const TableScan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableScan(TableScan&& from) noexcept
    : TableScan() {
    *this = ::std::move(from);
  }

  inline TableScan& operator=(TableScan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableScan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableScan* internal_default_instance() {
    return reinterpret_cast<const TableScan*>(
               &_TableScan_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(TableScan* other);
  friend void swap(TableScan& a, TableScan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableScan* New() const PROTOBUF_FINAL { return New(NULL); }

  TableScan* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TableScan& from);
  void MergeFrom(const TableScan& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TableScan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tipb.ColumnInfo columns = 2;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 2;
  const ::tipb::ColumnInfo& columns(int index) const;
  ::tipb::ColumnInfo* mutable_columns(int index);
  ::tipb::ColumnInfo* add_columns();
  ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo >&
      columns() const;

  // optional int64 table_id = 1;
  bool has_table_id() const;
  void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  ::google::protobuf::int64 table_id() const;
  void set_table_id(::google::protobuf::int64 value);

  // optional bool desc = 3;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 3;
  bool desc() const;
  void set_desc(bool value);

  // @@protoc_insertion_point(class_scope:tipb.TableScan)
 private:
  void set_has_table_id();
  void clear_has_table_id();
  void set_has_desc();
  void clear_has_desc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo > columns_;
  ::google::protobuf::int64 table_id_;
  bool desc_;
  friend struct ::protobuf_executor_2eproto::TableStruct;
  friend void ::protobuf_executor_2eproto::InitDefaultsTableScanImpl();
};
// -------------------------------------------------------------------

class IndexScan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.IndexScan) */ {
 public:
  IndexScan();
  virtual ~IndexScan();

  IndexScan(const IndexScan& from);

  inline IndexScan& operator=(const IndexScan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IndexScan(IndexScan&& from) noexcept
    : IndexScan() {
    *this = ::std::move(from);
  }

  inline IndexScan& operator=(IndexScan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexScan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndexScan* internal_default_instance() {
    return reinterpret_cast<const IndexScan*>(
               &_IndexScan_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(IndexScan* other);
  friend void swap(IndexScan& a, IndexScan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IndexScan* New() const PROTOBUF_FINAL { return New(NULL); }

  IndexScan* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IndexScan& from);
  void MergeFrom(const IndexScan& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IndexScan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tipb.ColumnInfo columns = 3;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 3;
  const ::tipb::ColumnInfo& columns(int index) const;
  ::tipb::ColumnInfo* mutable_columns(int index);
  ::tipb::ColumnInfo* add_columns();
  ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo >*
      mutable_columns();
  const ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo >&
      columns() const;

  // optional int64 table_id = 1;
  bool has_table_id() const;
  void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  ::google::protobuf::int64 table_id() const;
  void set_table_id(::google::protobuf::int64 value);

  // optional int64 index_id = 2;
  bool has_index_id() const;
  void clear_index_id();
  static const int kIndexIdFieldNumber = 2;
  ::google::protobuf::int64 index_id() const;
  void set_index_id(::google::protobuf::int64 value);

  // optional bool desc = 4;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 4;
  bool desc() const;
  void set_desc(bool value);

  // optional bool unique = 5;
  bool has_unique() const;
  void clear_unique();
  static const int kUniqueFieldNumber = 5;
  bool unique() const;
  void set_unique(bool value);

  // @@protoc_insertion_point(class_scope:tipb.IndexScan)
 private:
  void set_has_table_id();
  void clear_has_table_id();
  void set_has_index_id();
  void clear_has_index_id();
  void set_has_desc();
  void clear_has_desc();
  void set_has_unique();
  void clear_has_unique();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo > columns_;
  ::google::protobuf::int64 table_id_;
  ::google::protobuf::int64 index_id_;
  bool desc_;
  bool unique_;
  friend struct ::protobuf_executor_2eproto::TableStruct;
  friend void ::protobuf_executor_2eproto::InitDefaultsIndexScanImpl();
};
// -------------------------------------------------------------------

class Selection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.Selection) */ {
 public:
  Selection();
  virtual ~Selection();

  Selection(const Selection& from);

  inline Selection& operator=(const Selection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Selection(Selection&& from) noexcept
    : Selection() {
    *this = ::std::move(from);
  }

  inline Selection& operator=(Selection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Selection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Selection* internal_default_instance() {
    return reinterpret_cast<const Selection*>(
               &_Selection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Selection* other);
  friend void swap(Selection& a, Selection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Selection* New() const PROTOBUF_FINAL { return New(NULL); }

  Selection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Selection& from);
  void MergeFrom(const Selection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Selection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tipb.Expr conditions = 1;
  int conditions_size() const;
  void clear_conditions();
  static const int kConditionsFieldNumber = 1;
  const ::tipb::Expr& conditions(int index) const;
  ::tipb::Expr* mutable_conditions(int index);
  ::tipb::Expr* add_conditions();
  ::google::protobuf::RepeatedPtrField< ::tipb::Expr >*
      mutable_conditions();
  const ::google::protobuf::RepeatedPtrField< ::tipb::Expr >&
      conditions() const;

  // @@protoc_insertion_point(class_scope:tipb.Selection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tipb::Expr > conditions_;
  friend struct ::protobuf_executor_2eproto::TableStruct;
  friend void ::protobuf_executor_2eproto::InitDefaultsSelectionImpl();
};
// -------------------------------------------------------------------

class Projection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.Projection) */ {
 public:
  Projection();
  virtual ~Projection();

  Projection(const Projection& from);

  inline Projection& operator=(const Projection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Projection(Projection&& from) noexcept
    : Projection() {
    *this = ::std::move(from);
  }

  inline Projection& operator=(Projection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Projection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Projection* internal_default_instance() {
    return reinterpret_cast<const Projection*>(
               &_Projection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Projection* other);
  friend void swap(Projection& a, Projection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Projection* New() const PROTOBUF_FINAL { return New(NULL); }

  Projection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Projection& from);
  void MergeFrom(const Projection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Projection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tipb.Expr exprs = 1;
  int exprs_size() const;
  void clear_exprs();
  static const int kExprsFieldNumber = 1;
  const ::tipb::Expr& exprs(int index) const;
  ::tipb::Expr* mutable_exprs(int index);
  ::tipb::Expr* add_exprs();
  ::google::protobuf::RepeatedPtrField< ::tipb::Expr >*
      mutable_exprs();
  const ::google::protobuf::RepeatedPtrField< ::tipb::Expr >&
      exprs() const;

  // @@protoc_insertion_point(class_scope:tipb.Projection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tipb::Expr > exprs_;
  friend struct ::protobuf_executor_2eproto::TableStruct;
  friend void ::protobuf_executor_2eproto::InitDefaultsProjectionImpl();
};
// -------------------------------------------------------------------

class Aggregation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.Aggregation) */ {
 public:
  Aggregation();
  virtual ~Aggregation();

  Aggregation(const Aggregation& from);

  inline Aggregation& operator=(const Aggregation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Aggregation(Aggregation&& from) noexcept
    : Aggregation() {
    *this = ::std::move(from);
  }

  inline Aggregation& operator=(Aggregation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Aggregation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Aggregation* internal_default_instance() {
    return reinterpret_cast<const Aggregation*>(
               &_Aggregation_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Aggregation* other);
  friend void swap(Aggregation& a, Aggregation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Aggregation* New() const PROTOBUF_FINAL { return New(NULL); }

  Aggregation* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Aggregation& from);
  void MergeFrom(const Aggregation& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Aggregation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tipb.Expr group_by = 1;
  int group_by_size() const;
  void clear_group_by();
  static const int kGroupByFieldNumber = 1;
  const ::tipb::Expr& group_by(int index) const;
  ::tipb::Expr* mutable_group_by(int index);
  ::tipb::Expr* add_group_by();
  ::google::protobuf::RepeatedPtrField< ::tipb::Expr >*
      mutable_group_by();
  const ::google::protobuf::RepeatedPtrField< ::tipb::Expr >&
      group_by() const;

  // repeated .tipb.Expr agg_func = 2;
  int agg_func_size() const;
  void clear_agg_func();
  static const int kAggFuncFieldNumber = 2;
  const ::tipb::Expr& agg_func(int index) const;
  ::tipb::Expr* mutable_agg_func(int index);
  ::tipb::Expr* add_agg_func();
  ::google::protobuf::RepeatedPtrField< ::tipb::Expr >*
      mutable_agg_func();
  const ::google::protobuf::RepeatedPtrField< ::tipb::Expr >&
      agg_func() const;

  // optional bool streamed = 3;
  bool has_streamed() const;
  void clear_streamed();
  static const int kStreamedFieldNumber = 3;
  bool streamed() const;
  void set_streamed(bool value);

  // @@protoc_insertion_point(class_scope:tipb.Aggregation)
 private:
  void set_has_streamed();
  void clear_has_streamed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tipb::Expr > group_by_;
  ::google::protobuf::RepeatedPtrField< ::tipb::Expr > agg_func_;
  bool streamed_;
  friend struct ::protobuf_executor_2eproto::TableStruct;
  friend void ::protobuf_executor_2eproto::InitDefaultsAggregationImpl();
};
// -------------------------------------------------------------------

class TopN : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.TopN) */ {
 public:
  TopN();
  virtual ~TopN();

  TopN(const TopN& from);

  inline TopN& operator=(const TopN& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TopN(TopN&& from) noexcept
    : TopN() {
    *this = ::std::move(from);
  }

  inline TopN& operator=(TopN&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopN& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TopN* internal_default_instance() {
    return reinterpret_cast<const TopN*>(
               &_TopN_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(TopN* other);
  friend void swap(TopN& a, TopN& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TopN* New() const PROTOBUF_FINAL { return New(NULL); }

  TopN* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TopN& from);
  void MergeFrom(const TopN& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TopN* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tipb.ByItem order_by = 1;
  int order_by_size() const;
  void clear_order_by();
  static const int kOrderByFieldNumber = 1;
  const ::tipb::ByItem& order_by(int index) const;
  ::tipb::ByItem* mutable_order_by(int index);
  ::tipb::ByItem* add_order_by();
  ::google::protobuf::RepeatedPtrField< ::tipb::ByItem >*
      mutable_order_by();
  const ::google::protobuf::RepeatedPtrField< ::tipb::ByItem >&
      order_by() const;

  // optional uint64 limit = 2;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  ::google::protobuf::uint64 limit() const;
  void set_limit(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tipb.TopN)
 private:
  void set_has_limit();
  void clear_has_limit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tipb::ByItem > order_by_;
  ::google::protobuf::uint64 limit_;
  friend struct ::protobuf_executor_2eproto::TableStruct;
  friend void ::protobuf_executor_2eproto::InitDefaultsTopNImpl();
};
// -------------------------------------------------------------------

class Limit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.Limit) */ {
 public:
  Limit();
  virtual ~Limit();

  Limit(const Limit& from);

  inline Limit& operator=(const Limit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Limit(Limit&& from) noexcept
    : Limit() {
    *this = ::std::move(from);
  }

  inline Limit& operator=(Limit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Limit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Limit* internal_default_instance() {
    return reinterpret_cast<const Limit*>(
               &_Limit_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Limit* other);
  friend void swap(Limit& a, Limit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Limit* New() const PROTOBUF_FINAL { return New(NULL); }

  Limit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Limit& from);
  void MergeFrom(const Limit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Limit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 limit = 1;
  bool has_limit() const;
  void clear_limit();
  static const int kLimitFieldNumber = 1;
  ::google::protobuf::uint64 limit() const;
  void set_limit(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tipb.Limit)
 private:
  void set_has_limit();
  void clear_has_limit();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 limit_;
  friend struct ::protobuf_executor_2eproto::TableStruct;
  friend void ::protobuf_executor_2eproto::InitDefaultsLimitImpl();
};
// -------------------------------------------------------------------

class ExecutorExecutionSummary : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.ExecutorExecutionSummary) */ {
 public:
  ExecutorExecutionSummary();
  virtual ~ExecutorExecutionSummary();

  ExecutorExecutionSummary(const ExecutorExecutionSummary& from);

  inline ExecutorExecutionSummary& operator=(const ExecutorExecutionSummary& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExecutorExecutionSummary(ExecutorExecutionSummary&& from) noexcept
    : ExecutorExecutionSummary() {
    *this = ::std::move(from);
  }

  inline ExecutorExecutionSummary& operator=(ExecutorExecutionSummary&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutorExecutionSummary& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExecutorExecutionSummary* internal_default_instance() {
    return reinterpret_cast<const ExecutorExecutionSummary*>(
               &_ExecutorExecutionSummary_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(ExecutorExecutionSummary* other);
  friend void swap(ExecutorExecutionSummary& a, ExecutorExecutionSummary& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExecutorExecutionSummary* New() const PROTOBUF_FINAL { return New(NULL); }

  ExecutorExecutionSummary* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ExecutorExecutionSummary& from);
  void MergeFrom(const ExecutorExecutionSummary& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ExecutorExecutionSummary* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 time_processed_ns = 1;
  bool has_time_processed_ns() const;
  void clear_time_processed_ns();
  static const int kTimeProcessedNsFieldNumber = 1;
  ::google::protobuf::uint64 time_processed_ns() const;
  void set_time_processed_ns(::google::protobuf::uint64 value);

  // optional uint64 num_produced_rows = 2;
  bool has_num_produced_rows() const;
  void clear_num_produced_rows();
  static const int kNumProducedRowsFieldNumber = 2;
  ::google::protobuf::uint64 num_produced_rows() const;
  void set_num_produced_rows(::google::protobuf::uint64 value);

  // optional uint64 num_iterations = 3;
  bool has_num_iterations() const;
  void clear_num_iterations();
  static const int kNumIterationsFieldNumber = 3;
  ::google::protobuf::uint64 num_iterations() const;
  void set_num_iterations(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tipb.ExecutorExecutionSummary)
 private:
  void set_has_time_processed_ns();
  void clear_has_time_processed_ns();
  void set_has_num_produced_rows();
  void clear_has_num_produced_rows();
  void set_has_num_iterations();
  void clear_has_num_iterations();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_processed_ns_;
  ::google::protobuf::uint64 num_produced_rows_;
  ::google::protobuf::uint64 num_iterations_;
  friend struct ::protobuf_executor_2eproto::TableStruct;
  friend void ::protobuf_executor_2eproto::InitDefaultsExecutorExecutionSummaryImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Executor

// optional .tipb.ExecType tp = 1;
inline bool Executor::has_tp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Executor::set_has_tp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Executor::clear_has_tp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Executor::clear_tp() {
  tp_ = 0;
  clear_has_tp();
}
inline ::tipb::ExecType Executor::tp() const {
  // @@protoc_insertion_point(field_get:tipb.Executor.tp)
  return static_cast< ::tipb::ExecType >(tp_);
}
inline void Executor::set_tp(::tipb::ExecType value) {
  assert(::tipb::ExecType_IsValid(value));
  set_has_tp();
  tp_ = value;
  // @@protoc_insertion_point(field_set:tipb.Executor.tp)
}

// optional .tipb.TableScan tbl_scan = 2;
inline bool Executor::has_tbl_scan() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Executor::set_has_tbl_scan() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Executor::clear_has_tbl_scan() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Executor::clear_tbl_scan() {
  if (tbl_scan_ != NULL) tbl_scan_->Clear();
  clear_has_tbl_scan();
}
inline const ::tipb::TableScan& Executor::tbl_scan() const {
  const ::tipb::TableScan* p = tbl_scan_;
  // @@protoc_insertion_point(field_get:tipb.Executor.tbl_scan)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::TableScan*>(
      &::tipb::_TableScan_default_instance_);
}
inline ::tipb::TableScan* Executor::release_tbl_scan() {
  // @@protoc_insertion_point(field_release:tipb.Executor.tbl_scan)
  clear_has_tbl_scan();
  ::tipb::TableScan* temp = tbl_scan_;
  tbl_scan_ = NULL;
  return temp;
}
inline ::tipb::TableScan* Executor::mutable_tbl_scan() {
  set_has_tbl_scan();
  if (tbl_scan_ == NULL) {
    tbl_scan_ = new ::tipb::TableScan;
  }
  // @@protoc_insertion_point(field_mutable:tipb.Executor.tbl_scan)
  return tbl_scan_;
}
inline void Executor::set_allocated_tbl_scan(::tipb::TableScan* tbl_scan) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tbl_scan_;
  }
  if (tbl_scan) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tbl_scan = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tbl_scan, submessage_arena);
    }
    set_has_tbl_scan();
  } else {
    clear_has_tbl_scan();
  }
  tbl_scan_ = tbl_scan;
  // @@protoc_insertion_point(field_set_allocated:tipb.Executor.tbl_scan)
}

// optional .tipb.IndexScan idx_scan = 3;
inline bool Executor::has_idx_scan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Executor::set_has_idx_scan() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Executor::clear_has_idx_scan() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Executor::clear_idx_scan() {
  if (idx_scan_ != NULL) idx_scan_->Clear();
  clear_has_idx_scan();
}
inline const ::tipb::IndexScan& Executor::idx_scan() const {
  const ::tipb::IndexScan* p = idx_scan_;
  // @@protoc_insertion_point(field_get:tipb.Executor.idx_scan)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::IndexScan*>(
      &::tipb::_IndexScan_default_instance_);
}
inline ::tipb::IndexScan* Executor::release_idx_scan() {
  // @@protoc_insertion_point(field_release:tipb.Executor.idx_scan)
  clear_has_idx_scan();
  ::tipb::IndexScan* temp = idx_scan_;
  idx_scan_ = NULL;
  return temp;
}
inline ::tipb::IndexScan* Executor::mutable_idx_scan() {
  set_has_idx_scan();
  if (idx_scan_ == NULL) {
    idx_scan_ = new ::tipb::IndexScan;
  }
  // @@protoc_insertion_point(field_mutable:tipb.Executor.idx_scan)
  return idx_scan_;
}
inline void Executor::set_allocated_idx_scan(::tipb::IndexScan* idx_scan) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete idx_scan_;
  }
  if (idx_scan) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      idx_scan = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, idx_scan, submessage_arena);
    }
    set_has_idx_scan();
  } else {
    clear_has_idx_scan();
  }
  idx_scan_ = idx_scan;
  // @@protoc_insertion_point(field_set_allocated:tipb.Executor.idx_scan)
}

// optional .tipb.Selection selection = 4;
inline bool Executor::has_selection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Executor::set_has_selection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Executor::clear_has_selection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Executor::clear_selection() {
  if (selection_ != NULL) selection_->Clear();
  clear_has_selection();
}
inline const ::tipb::Selection& Executor::selection() const {
  const ::tipb::Selection* p = selection_;
  // @@protoc_insertion_point(field_get:tipb.Executor.selection)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::Selection*>(
      &::tipb::_Selection_default_instance_);
}
inline ::tipb::Selection* Executor::release_selection() {
  // @@protoc_insertion_point(field_release:tipb.Executor.selection)
  clear_has_selection();
  ::tipb::Selection* temp = selection_;
  selection_ = NULL;
  return temp;
}
inline ::tipb::Selection* Executor::mutable_selection() {
  set_has_selection();
  if (selection_ == NULL) {
    selection_ = new ::tipb::Selection;
  }
  // @@protoc_insertion_point(field_mutable:tipb.Executor.selection)
  return selection_;
}
inline void Executor::set_allocated_selection(::tipb::Selection* selection) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete selection_;
  }
  if (selection) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      selection = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, selection, submessage_arena);
    }
    set_has_selection();
  } else {
    clear_has_selection();
  }
  selection_ = selection;
  // @@protoc_insertion_point(field_set_allocated:tipb.Executor.selection)
}

// optional .tipb.Aggregation aggregation = 5;
inline bool Executor::has_aggregation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Executor::set_has_aggregation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Executor::clear_has_aggregation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Executor::clear_aggregation() {
  if (aggregation_ != NULL) aggregation_->Clear();
  clear_has_aggregation();
}
inline const ::tipb::Aggregation& Executor::aggregation() const {
  const ::tipb::Aggregation* p = aggregation_;
  // @@protoc_insertion_point(field_get:tipb.Executor.aggregation)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::Aggregation*>(
      &::tipb::_Aggregation_default_instance_);
}
inline ::tipb::Aggregation* Executor::release_aggregation() {
  // @@protoc_insertion_point(field_release:tipb.Executor.aggregation)
  clear_has_aggregation();
  ::tipb::Aggregation* temp = aggregation_;
  aggregation_ = NULL;
  return temp;
}
inline ::tipb::Aggregation* Executor::mutable_aggregation() {
  set_has_aggregation();
  if (aggregation_ == NULL) {
    aggregation_ = new ::tipb::Aggregation;
  }
  // @@protoc_insertion_point(field_mutable:tipb.Executor.aggregation)
  return aggregation_;
}
inline void Executor::set_allocated_aggregation(::tipb::Aggregation* aggregation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete aggregation_;
  }
  if (aggregation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      aggregation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, aggregation, submessage_arena);
    }
    set_has_aggregation();
  } else {
    clear_has_aggregation();
  }
  aggregation_ = aggregation;
  // @@protoc_insertion_point(field_set_allocated:tipb.Executor.aggregation)
}

// optional .tipb.TopN topN = 6;
inline bool Executor::has_topn() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Executor::set_has_topn() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Executor::clear_has_topn() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Executor::clear_topn() {
  if (topn_ != NULL) topn_->Clear();
  clear_has_topn();
}
inline const ::tipb::TopN& Executor::topn() const {
  const ::tipb::TopN* p = topn_;
  // @@protoc_insertion_point(field_get:tipb.Executor.topN)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::TopN*>(
      &::tipb::_TopN_default_instance_);
}
inline ::tipb::TopN* Executor::release_topn() {
  // @@protoc_insertion_point(field_release:tipb.Executor.topN)
  clear_has_topn();
  ::tipb::TopN* temp = topn_;
  topn_ = NULL;
  return temp;
}
inline ::tipb::TopN* Executor::mutable_topn() {
  set_has_topn();
  if (topn_ == NULL) {
    topn_ = new ::tipb::TopN;
  }
  // @@protoc_insertion_point(field_mutable:tipb.Executor.topN)
  return topn_;
}
inline void Executor::set_allocated_topn(::tipb::TopN* topn) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete topn_;
  }
  if (topn) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      topn = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, topn, submessage_arena);
    }
    set_has_topn();
  } else {
    clear_has_topn();
  }
  topn_ = topn;
  // @@protoc_insertion_point(field_set_allocated:tipb.Executor.topN)
}

// optional .tipb.Limit limit = 7;
inline bool Executor::has_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Executor::set_has_limit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Executor::clear_has_limit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Executor::clear_limit() {
  if (limit_ != NULL) limit_->Clear();
  clear_has_limit();
}
inline const ::tipb::Limit& Executor::limit() const {
  const ::tipb::Limit* p = limit_;
  // @@protoc_insertion_point(field_get:tipb.Executor.limit)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::Limit*>(
      &::tipb::_Limit_default_instance_);
}
inline ::tipb::Limit* Executor::release_limit() {
  // @@protoc_insertion_point(field_release:tipb.Executor.limit)
  clear_has_limit();
  ::tipb::Limit* temp = limit_;
  limit_ = NULL;
  return temp;
}
inline ::tipb::Limit* Executor::mutable_limit() {
  set_has_limit();
  if (limit_ == NULL) {
    limit_ = new ::tipb::Limit;
  }
  // @@protoc_insertion_point(field_mutable:tipb.Executor.limit)
  return limit_;
}
inline void Executor::set_allocated_limit(::tipb::Limit* limit) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete limit_;
  }
  if (limit) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      limit = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, limit, submessage_arena);
    }
    set_has_limit();
  } else {
    clear_has_limit();
  }
  limit_ = limit;
  // @@protoc_insertion_point(field_set_allocated:tipb.Executor.limit)
}

// optional .tipb.Aggregation stream_agg = 8;
inline bool Executor::has_stream_agg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Executor::set_has_stream_agg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Executor::clear_has_stream_agg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Executor::clear_stream_agg() {
  if (stream_agg_ != NULL) stream_agg_->Clear();
  clear_has_stream_agg();
}
inline const ::tipb::Aggregation& Executor::stream_agg() const {
  const ::tipb::Aggregation* p = stream_agg_;
  // @@protoc_insertion_point(field_get:tipb.Executor.stream_agg)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::Aggregation*>(
      &::tipb::_Aggregation_default_instance_);
}
inline ::tipb::Aggregation* Executor::release_stream_agg() {
  // @@protoc_insertion_point(field_release:tipb.Executor.stream_agg)
  clear_has_stream_agg();
  ::tipb::Aggregation* temp = stream_agg_;
  stream_agg_ = NULL;
  return temp;
}
inline ::tipb::Aggregation* Executor::mutable_stream_agg() {
  set_has_stream_agg();
  if (stream_agg_ == NULL) {
    stream_agg_ = new ::tipb::Aggregation;
  }
  // @@protoc_insertion_point(field_mutable:tipb.Executor.stream_agg)
  return stream_agg_;
}
inline void Executor::set_allocated_stream_agg(::tipb::Aggregation* stream_agg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stream_agg_;
  }
  if (stream_agg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stream_agg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stream_agg, submessage_arena);
    }
    set_has_stream_agg();
  } else {
    clear_has_stream_agg();
  }
  stream_agg_ = stream_agg;
  // @@protoc_insertion_point(field_set_allocated:tipb.Executor.stream_agg)
}

// -------------------------------------------------------------------

// TableScan

// optional int64 table_id = 1;
inline bool TableScan::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableScan::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableScan::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableScan::clear_table_id() {
  table_id_ = GOOGLE_LONGLONG(0);
  clear_has_table_id();
}
inline ::google::protobuf::int64 TableScan::table_id() const {
  // @@protoc_insertion_point(field_get:tipb.TableScan.table_id)
  return table_id_;
}
inline void TableScan::set_table_id(::google::protobuf::int64 value) {
  set_has_table_id();
  table_id_ = value;
  // @@protoc_insertion_point(field_set:tipb.TableScan.table_id)
}

// repeated .tipb.ColumnInfo columns = 2;
inline int TableScan::columns_size() const {
  return columns_.size();
}
inline const ::tipb::ColumnInfo& TableScan::columns(int index) const {
  // @@protoc_insertion_point(field_get:tipb.TableScan.columns)
  return columns_.Get(index);
}
inline ::tipb::ColumnInfo* TableScan::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:tipb.TableScan.columns)
  return columns_.Mutable(index);
}
inline ::tipb::ColumnInfo* TableScan::add_columns() {
  // @@protoc_insertion_point(field_add:tipb.TableScan.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo >*
TableScan::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:tipb.TableScan.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo >&
TableScan::columns() const {
  // @@protoc_insertion_point(field_list:tipb.TableScan.columns)
  return columns_;
}

// optional bool desc = 3;
inline bool TableScan::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableScan::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableScan::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableScan::clear_desc() {
  desc_ = false;
  clear_has_desc();
}
inline bool TableScan::desc() const {
  // @@protoc_insertion_point(field_get:tipb.TableScan.desc)
  return desc_;
}
inline void TableScan::set_desc(bool value) {
  set_has_desc();
  desc_ = value;
  // @@protoc_insertion_point(field_set:tipb.TableScan.desc)
}

// -------------------------------------------------------------------

// IndexScan

// optional int64 table_id = 1;
inline bool IndexScan::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IndexScan::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IndexScan::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IndexScan::clear_table_id() {
  table_id_ = GOOGLE_LONGLONG(0);
  clear_has_table_id();
}
inline ::google::protobuf::int64 IndexScan::table_id() const {
  // @@protoc_insertion_point(field_get:tipb.IndexScan.table_id)
  return table_id_;
}
inline void IndexScan::set_table_id(::google::protobuf::int64 value) {
  set_has_table_id();
  table_id_ = value;
  // @@protoc_insertion_point(field_set:tipb.IndexScan.table_id)
}

// optional int64 index_id = 2;
inline bool IndexScan::has_index_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IndexScan::set_has_index_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IndexScan::clear_has_index_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IndexScan::clear_index_id() {
  index_id_ = GOOGLE_LONGLONG(0);
  clear_has_index_id();
}
inline ::google::protobuf::int64 IndexScan::index_id() const {
  // @@protoc_insertion_point(field_get:tipb.IndexScan.index_id)
  return index_id_;
}
inline void IndexScan::set_index_id(::google::protobuf::int64 value) {
  set_has_index_id();
  index_id_ = value;
  // @@protoc_insertion_point(field_set:tipb.IndexScan.index_id)
}

// repeated .tipb.ColumnInfo columns = 3;
inline int IndexScan::columns_size() const {
  return columns_.size();
}
inline const ::tipb::ColumnInfo& IndexScan::columns(int index) const {
  // @@protoc_insertion_point(field_get:tipb.IndexScan.columns)
  return columns_.Get(index);
}
inline ::tipb::ColumnInfo* IndexScan::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:tipb.IndexScan.columns)
  return columns_.Mutable(index);
}
inline ::tipb::ColumnInfo* IndexScan::add_columns() {
  // @@protoc_insertion_point(field_add:tipb.IndexScan.columns)
  return columns_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo >*
IndexScan::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:tipb.IndexScan.columns)
  return &columns_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo >&
IndexScan::columns() const {
  // @@protoc_insertion_point(field_list:tipb.IndexScan.columns)
  return columns_;
}

// optional bool desc = 4;
inline bool IndexScan::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IndexScan::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IndexScan::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IndexScan::clear_desc() {
  desc_ = false;
  clear_has_desc();
}
inline bool IndexScan::desc() const {
  // @@protoc_insertion_point(field_get:tipb.IndexScan.desc)
  return desc_;
}
inline void IndexScan::set_desc(bool value) {
  set_has_desc();
  desc_ = value;
  // @@protoc_insertion_point(field_set:tipb.IndexScan.desc)
}

// optional bool unique = 5;
inline bool IndexScan::has_unique() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IndexScan::set_has_unique() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IndexScan::clear_has_unique() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IndexScan::clear_unique() {
  unique_ = false;
  clear_has_unique();
}
inline bool IndexScan::unique() const {
  // @@protoc_insertion_point(field_get:tipb.IndexScan.unique)
  return unique_;
}
inline void IndexScan::set_unique(bool value) {
  set_has_unique();
  unique_ = value;
  // @@protoc_insertion_point(field_set:tipb.IndexScan.unique)
}

// -------------------------------------------------------------------

// Selection

// repeated .tipb.Expr conditions = 1;
inline int Selection::conditions_size() const {
  return conditions_.size();
}
inline const ::tipb::Expr& Selection::conditions(int index) const {
  // @@protoc_insertion_point(field_get:tipb.Selection.conditions)
  return conditions_.Get(index);
}
inline ::tipb::Expr* Selection::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:tipb.Selection.conditions)
  return conditions_.Mutable(index);
}
inline ::tipb::Expr* Selection::add_conditions() {
  // @@protoc_insertion_point(field_add:tipb.Selection.conditions)
  return conditions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tipb::Expr >*
Selection::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:tipb.Selection.conditions)
  return &conditions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tipb::Expr >&
Selection::conditions() const {
  // @@protoc_insertion_point(field_list:tipb.Selection.conditions)
  return conditions_;
}

// -------------------------------------------------------------------

// Projection

// repeated .tipb.Expr exprs = 1;
inline int Projection::exprs_size() const {
  return exprs_.size();
}
inline const ::tipb::Expr& Projection::exprs(int index) const {
  // @@protoc_insertion_point(field_get:tipb.Projection.exprs)
  return exprs_.Get(index);
}
inline ::tipb::Expr* Projection::mutable_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:tipb.Projection.exprs)
  return exprs_.Mutable(index);
}
inline ::tipb::Expr* Projection::add_exprs() {
  // @@protoc_insertion_point(field_add:tipb.Projection.exprs)
  return exprs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tipb::Expr >*
Projection::mutable_exprs() {
  // @@protoc_insertion_point(field_mutable_list:tipb.Projection.exprs)
  return &exprs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tipb::Expr >&
Projection::exprs() const {
  // @@protoc_insertion_point(field_list:tipb.Projection.exprs)
  return exprs_;
}

// -------------------------------------------------------------------

// Aggregation

// repeated .tipb.Expr group_by = 1;
inline int Aggregation::group_by_size() const {
  return group_by_.size();
}
inline const ::tipb::Expr& Aggregation::group_by(int index) const {
  // @@protoc_insertion_point(field_get:tipb.Aggregation.group_by)
  return group_by_.Get(index);
}
inline ::tipb::Expr* Aggregation::mutable_group_by(int index) {
  // @@protoc_insertion_point(field_mutable:tipb.Aggregation.group_by)
  return group_by_.Mutable(index);
}
inline ::tipb::Expr* Aggregation::add_group_by() {
  // @@protoc_insertion_point(field_add:tipb.Aggregation.group_by)
  return group_by_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tipb::Expr >*
Aggregation::mutable_group_by() {
  // @@protoc_insertion_point(field_mutable_list:tipb.Aggregation.group_by)
  return &group_by_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tipb::Expr >&
Aggregation::group_by() const {
  // @@protoc_insertion_point(field_list:tipb.Aggregation.group_by)
  return group_by_;
}

// repeated .tipb.Expr agg_func = 2;
inline int Aggregation::agg_func_size() const {
  return agg_func_.size();
}
inline const ::tipb::Expr& Aggregation::agg_func(int index) const {
  // @@protoc_insertion_point(field_get:tipb.Aggregation.agg_func)
  return agg_func_.Get(index);
}
inline ::tipb::Expr* Aggregation::mutable_agg_func(int index) {
  // @@protoc_insertion_point(field_mutable:tipb.Aggregation.agg_func)
  return agg_func_.Mutable(index);
}
inline ::tipb::Expr* Aggregation::add_agg_func() {
  // @@protoc_insertion_point(field_add:tipb.Aggregation.agg_func)
  return agg_func_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tipb::Expr >*
Aggregation::mutable_agg_func() {
  // @@protoc_insertion_point(field_mutable_list:tipb.Aggregation.agg_func)
  return &agg_func_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tipb::Expr >&
Aggregation::agg_func() const {
  // @@protoc_insertion_point(field_list:tipb.Aggregation.agg_func)
  return agg_func_;
}

// optional bool streamed = 3;
inline bool Aggregation::has_streamed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Aggregation::set_has_streamed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Aggregation::clear_has_streamed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Aggregation::clear_streamed() {
  streamed_ = false;
  clear_has_streamed();
}
inline bool Aggregation::streamed() const {
  // @@protoc_insertion_point(field_get:tipb.Aggregation.streamed)
  return streamed_;
}
inline void Aggregation::set_streamed(bool value) {
  set_has_streamed();
  streamed_ = value;
  // @@protoc_insertion_point(field_set:tipb.Aggregation.streamed)
}

// -------------------------------------------------------------------

// TopN

// repeated .tipb.ByItem order_by = 1;
inline int TopN::order_by_size() const {
  return order_by_.size();
}
inline const ::tipb::ByItem& TopN::order_by(int index) const {
  // @@protoc_insertion_point(field_get:tipb.TopN.order_by)
  return order_by_.Get(index);
}
inline ::tipb::ByItem* TopN::mutable_order_by(int index) {
  // @@protoc_insertion_point(field_mutable:tipb.TopN.order_by)
  return order_by_.Mutable(index);
}
inline ::tipb::ByItem* TopN::add_order_by() {
  // @@protoc_insertion_point(field_add:tipb.TopN.order_by)
  return order_by_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tipb::ByItem >*
TopN::mutable_order_by() {
  // @@protoc_insertion_point(field_mutable_list:tipb.TopN.order_by)
  return &order_by_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tipb::ByItem >&
TopN::order_by() const {
  // @@protoc_insertion_point(field_list:tipb.TopN.order_by)
  return order_by_;
}

// optional uint64 limit = 2;
inline bool TopN::has_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopN::set_has_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopN::clear_has_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopN::clear_limit() {
  limit_ = GOOGLE_ULONGLONG(0);
  clear_has_limit();
}
inline ::google::protobuf::uint64 TopN::limit() const {
  // @@protoc_insertion_point(field_get:tipb.TopN.limit)
  return limit_;
}
inline void TopN::set_limit(::google::protobuf::uint64 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:tipb.TopN.limit)
}

// -------------------------------------------------------------------

// Limit

// optional uint64 limit = 1;
inline bool Limit::has_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Limit::set_has_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Limit::clear_has_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Limit::clear_limit() {
  limit_ = GOOGLE_ULONGLONG(0);
  clear_has_limit();
}
inline ::google::protobuf::uint64 Limit::limit() const {
  // @@protoc_insertion_point(field_get:tipb.Limit.limit)
  return limit_;
}
inline void Limit::set_limit(::google::protobuf::uint64 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:tipb.Limit.limit)
}

// -------------------------------------------------------------------

// ExecutorExecutionSummary

// optional uint64 time_processed_ns = 1;
inline bool ExecutorExecutionSummary::has_time_processed_ns() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutorExecutionSummary::set_has_time_processed_ns() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutorExecutionSummary::clear_has_time_processed_ns() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutorExecutionSummary::clear_time_processed_ns() {
  time_processed_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_time_processed_ns();
}
inline ::google::protobuf::uint64 ExecutorExecutionSummary::time_processed_ns() const {
  // @@protoc_insertion_point(field_get:tipb.ExecutorExecutionSummary.time_processed_ns)
  return time_processed_ns_;
}
inline void ExecutorExecutionSummary::set_time_processed_ns(::google::protobuf::uint64 value) {
  set_has_time_processed_ns();
  time_processed_ns_ = value;
  // @@protoc_insertion_point(field_set:tipb.ExecutorExecutionSummary.time_processed_ns)
}

// optional uint64 num_produced_rows = 2;
inline bool ExecutorExecutionSummary::has_num_produced_rows() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutorExecutionSummary::set_has_num_produced_rows() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutorExecutionSummary::clear_has_num_produced_rows() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutorExecutionSummary::clear_num_produced_rows() {
  num_produced_rows_ = GOOGLE_ULONGLONG(0);
  clear_has_num_produced_rows();
}
inline ::google::protobuf::uint64 ExecutorExecutionSummary::num_produced_rows() const {
  // @@protoc_insertion_point(field_get:tipb.ExecutorExecutionSummary.num_produced_rows)
  return num_produced_rows_;
}
inline void ExecutorExecutionSummary::set_num_produced_rows(::google::protobuf::uint64 value) {
  set_has_num_produced_rows();
  num_produced_rows_ = value;
  // @@protoc_insertion_point(field_set:tipb.ExecutorExecutionSummary.num_produced_rows)
}

// optional uint64 num_iterations = 3;
inline bool ExecutorExecutionSummary::has_num_iterations() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecutorExecutionSummary::set_has_num_iterations() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecutorExecutionSummary::clear_has_num_iterations() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecutorExecutionSummary::clear_num_iterations() {
  num_iterations_ = GOOGLE_ULONGLONG(0);
  clear_has_num_iterations();
}
inline ::google::protobuf::uint64 ExecutorExecutionSummary::num_iterations() const {
  // @@protoc_insertion_point(field_get:tipb.ExecutorExecutionSummary.num_iterations)
  return num_iterations_;
}
inline void ExecutorExecutionSummary::set_num_iterations(::google::protobuf::uint64 value) {
  set_has_num_iterations();
  num_iterations_ = value;
  // @@protoc_insertion_point(field_set:tipb.ExecutorExecutionSummary.num_iterations)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tipb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tipb::ExecType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tipb::ExecType>() {
  return ::tipb::ExecType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_executor_2eproto__INCLUDED
