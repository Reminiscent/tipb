// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: expression.proto

#include "expression.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// This is a temporary google only hack
#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
#include "third_party/protobuf/version.h"
#endif
// @@protoc_insertion_point(includes)
namespace tipb {
class FieldTypeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<FieldType>
      _instance;
} _FieldType_default_instance_;
class ExprDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Expr>
      _instance;
} _Expr_default_instance_;
class ByItemDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<ByItem>
      _instance;
} _ByItem_default_instance_;
}  // namespace tipb
namespace protobuf_expression_2eproto {
void InitDefaultsFieldTypeImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  {
    void* ptr = &::tipb::_FieldType_default_instance_;
    new (ptr) ::tipb::FieldType();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tipb::FieldType::InitAsDefaultInstance();
}

void InitDefaultsFieldType() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsFieldTypeImpl);
}

void InitDefaultsExprImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_expression_2eproto::InitDefaultsFieldType();
  {
    void* ptr = &::tipb::_Expr_default_instance_;
    new (ptr) ::tipb::Expr();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tipb::Expr::InitAsDefaultInstance();
}

void InitDefaultsExpr() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsExprImpl);
}

void InitDefaultsByItemImpl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#ifdef GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  ::google::protobuf::internal::InitProtobufDefaultsForceUnique();
#else
  ::google::protobuf::internal::InitProtobufDefaults();
#endif  // GOOGLE_PROTOBUF_ENFORCE_UNIQUENESS
  protobuf_expression_2eproto::InitDefaultsExpr();
  {
    void* ptr = &::tipb::_ByItem_default_instance_;
    new (ptr) ::tipb::ByItem();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::tipb::ByItem::InitAsDefaultInstance();
}

void InitDefaultsByItem() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &InitDefaultsByItemImpl);
}

::google::protobuf::Metadata file_level_metadata[3];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors[2];

const ::google::protobuf::uint32 TableStruct::offsets[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::FieldType, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::FieldType, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::FieldType, tp_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::FieldType, flag_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::FieldType, flen_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::FieldType, decimal_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::FieldType, collate_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::FieldType, charset_),
  1,
  2,
  3,
  4,
  5,
  0,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::Expr, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::Expr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::Expr, tp_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::Expr, val_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::Expr, children_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::Expr, sig_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::Expr, field_type_),
  2,
  0,
  ~0u,
  3,
  1,
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::ByItem, _has_bits_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::ByItem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::ByItem, expr_),
  GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(::tipb::ByItem, desc_),
  0,
  1,
};
static const ::google::protobuf::internal::MigrationSchema schemas[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, sizeof(::tipb::FieldType)},
  { 17, 27, sizeof(::tipb::Expr)},
  { 32, 39, sizeof(::tipb::ByItem)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::tipb::_FieldType_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::tipb::_Expr_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::tipb::_ByItem_default_instance_),
};

void protobuf_AssignDescriptors() {
  AddDescriptors();
  ::google::protobuf::MessageFactory* factory = NULL;
  AssignDescriptors(
      "expression.proto", schemas, file_default_instances, TableStruct::offsets, factory,
      file_level_metadata, file_level_enum_descriptors, NULL);
}

void protobuf_AssignDescriptorsOnce() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &protobuf_AssignDescriptors);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_PROTOBUF_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::internal::RegisterAllTypes(file_level_metadata, 3);
}

void AddDescriptorsImpl() {
  InitDefaults();
  static const char descriptor[] GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE(protodesc_cold) = {
      "\n\020expression.proto\022\004tipb\"f\n\tFieldType\022\n\n"
      "\002tp\030\001 \001(\005\022\014\n\004flag\030\002 \001(\r\022\014\n\004flen\030\003 \001(\005\022\017\n"
      "\007decimal\030\004 \001(\005\022\017\n\007collate\030\005 \001(\005\022\017\n\007chars"
      "et\030\006 \001(\t\"\224\001\n\004Expr\022\032\n\002tp\030\001 \001(\0162\016.tipb.Exp"
      "rType\022\013\n\003val\030\002 \001(\014\022\034\n\010children\030\003 \003(\0132\n.t"
      "ipb.Expr\022 \n\003sig\030\004 \001(\0162\023.tipb.ScalarFuncS"
      "ig\022#\n\nfield_type\030\005 \001(\0132\017.tipb.FieldType\""
      "0\n\006ByItem\022\030\n\004expr\030\001 \001(\0132\n.tipb.Expr\022\014\n\004d"
      "esc\030\002 \001(\010*\226\004\n\010ExprType\022\010\n\004Null\020\000\022\t\n\005Int6"
      "4\020\001\022\n\n\006Uint64\020\002\022\013\n\007Float32\020\003\022\013\n\007Float64\020"
      "\004\022\n\n\006String\020\005\022\t\n\005Bytes\020\006\022\014\n\010MysqlBit\020e\022\020"
      "\n\014MysqlDecimal\020f\022\021\n\rMysqlDuration\020g\022\r\n\tM"
      "ysqlEnum\020h\022\014\n\010MysqlHex\020i\022\014\n\010MysqlSet\020j\022\r"
      "\n\tMysqlTime\020k\022\r\n\tMysqlJson\020l\022\016\n\tValueLis"
      "t\020\227\001\022\016\n\tColumnRef\020\311\001\022\n\n\005Count\020\271\027\022\010\n\003Sum\020"
      "\272\027\022\010\n\003Avg\020\273\027\022\010\n\003Min\020\274\027\022\010\n\003Max\020\275\027\022\n\n\005Firs"
      "t\020\276\027\022\020\n\013GroupConcat\020\277\027\022\017\n\nAgg_BitAnd\020\300\027\022"
      "\016\n\tAgg_BitOr\020\301\027\022\017\n\nAgg_BitXor\020\302\027\022\010\n\003Std\020"
      "\303\027\022\013\n\006Stddev\020\304\027\022\016\n\tStddevPop\020\305\027\022\017\n\nStdde"
      "vSamp\020\306\027\022\013\n\006VarPop\020\307\027\022\014\n\007VarSamp\020\310\027\022\r\n\010V"
      "ariance\020\311\027\022\021\n\014JsonArrayAgg\020\312\027\022\022\n\rJsonObj"
      "ectAgg\020\313\027\022\017\n\nScalarFunc\020\220N*\331E\n\rScalarFun"
      "cSig\022\020\n\014CastIntAsInt\020\000\022\021\n\rCastIntAsReal\020"
      "\001\022\023\n\017CastIntAsString\020\002\022\024\n\020CastIntAsDecim"
      "al\020\003\022\021\n\rCastIntAsTime\020\004\022\025\n\021CastIntAsDura"
      "tion\020\005\022\021\n\rCastIntAsJson\020\006\022\021\n\rCastRealAsI"
      "nt\020\n\022\022\n\016CastRealAsReal\020\013\022\024\n\020CastRealAsSt"
      "ring\020\014\022\025\n\021CastRealAsDecimal\020\r\022\022\n\016CastRea"
      "lAsTime\020\016\022\026\n\022CastRealAsDuration\020\017\022\022\n\016Cas"
      "tRealAsJson\020\020\022\024\n\020CastDecimalAsInt\020\024\022\025\n\021C"
      "astDecimalAsReal\020\025\022\027\n\023CastDecimalAsStrin"
      "g\020\026\022\030\n\024CastDecimalAsDecimal\020\027\022\025\n\021CastDec"
      "imalAsTime\020\030\022\031\n\025CastDecimalAsDuration\020\031\022"
      "\025\n\021CastDecimalAsJson\020\032\022\023\n\017CastStringAsIn"
      "t\020\036\022\024\n\020CastStringAsReal\020\037\022\026\n\022CastStringA"
      "sString\020 \022\027\n\023CastStringAsDecimal\020!\022\024\n\020Ca"
      "stStringAsTime\020\"\022\030\n\024CastStringAsDuration"
      "\020#\022\024\n\020CastStringAsJson\020$\022\021\n\rCastTimeAsIn"
      "t\020(\022\022\n\016CastTimeAsReal\020)\022\024\n\020CastTimeAsStr"
      "ing\020*\022\025\n\021CastTimeAsDecimal\020+\022\022\n\016CastTime"
      "AsTime\020,\022\026\n\022CastTimeAsDuration\020-\022\022\n\016Cast"
      "TimeAsJson\020.\022\025\n\021CastDurationAsInt\0202\022\026\n\022C"
      "astDurationAsReal\0203\022\030\n\024CastDurationAsStr"
      "ing\0204\022\031\n\025CastDurationAsDecimal\0205\022\026\n\022Cast"
      "DurationAsTime\0206\022\032\n\026CastDurationAsDurati"
      "on\0207\022\026\n\022CastDurationAsJson\0208\022\021\n\rCastJson"
      "AsInt\020<\022\022\n\016CastJsonAsReal\020=\022\024\n\020CastJsonA"
      "sString\020>\022\025\n\021CastJsonAsDecimal\020\?\022\022\n\016Cast"
      "JsonAsTime\020@\022\026\n\022CastJsonAsDuration\020A\022\022\n\016"
      "CastJsonAsJson\020B\022\020\n\013CoalesceInt\020\351 \022\021\n\014Co"
      "alesceReal\020\352 \022\024\n\017CoalesceDecimal\020\353 \022\023\n\016C"
      "oalesceString\020\354 \022\021\n\014CoalesceTime\020\355 \022\025\n\020C"
      "oalesceDuration\020\356 \022\021\n\014CoalesceJson\020\357 \022\t\n"
      "\005LTInt\020d\022\n\n\006LTReal\020e\022\r\n\tLTDecimal\020f\022\014\n\010L"
      "TString\020g\022\n\n\006LTTime\020h\022\016\n\nLTDuration\020i\022\n\n"
      "\006LTJson\020j\022\t\n\005LEInt\020n\022\n\n\006LEReal\020o\022\r\n\tLEDe"
      "cimal\020p\022\014\n\010LEString\020q\022\n\n\006LETime\020r\022\016\n\nLED"
      "uration\020s\022\n\n\006LEJson\020t\022\t\n\005GTInt\020x\022\n\n\006GTRe"
      "al\020y\022\r\n\tGTDecimal\020z\022\014\n\010GTString\020{\022\n\n\006GTT"
      "ime\020|\022\016\n\nGTDuration\020}\022\n\n\006GTJson\020~\022\020\n\013Gre"
      "atestInt\020\367 \022\021\n\014GreatestReal\020\370 \022\024\n\017Greate"
      "stDecimal\020\371 \022\023\n\016GreatestString\020\372 \022\021\n\014Gre"
      "atestTime\020\373 \022\r\n\010LeastInt\020\374 \022\016\n\tLeastReal"
      "\020\375 \022\021\n\014LeastDecimal\020\376 \022\020\n\013LeastString\020\377 "
      "\022\016\n\tLeastTime\020\200!\022\020\n\013IntervalInt\020\201!\022\021\n\014In"
      "tervalReal\020\202!\022\n\n\005GEInt\020\202\001\022\013\n\006GEReal\020\203\001\022\016"
      "\n\tGEDecimal\020\204\001\022\r\n\010GEString\020\205\001\022\013\n\006GETime\020"
      "\206\001\022\017\n\nGEDuration\020\207\001\022\013\n\006GEJson\020\210\001\022\n\n\005EQIn"
      "t\020\214\001\022\013\n\006EQReal\020\215\001\022\016\n\tEQDecimal\020\216\001\022\r\n\010EQS"
      "tring\020\217\001\022\013\n\006EQTime\020\220\001\022\017\n\nEQDuration\020\221\001\022\013"
      "\n\006EQJson\020\222\001\022\n\n\005NEInt\020\226\001\022\013\n\006NEReal\020\227\001\022\016\n\t"
      "NEDecimal\020\230\001\022\r\n\010NEString\020\231\001\022\013\n\006NETime\020\232\001"
      "\022\017\n\nNEDuration\020\233\001\022\013\n\006NEJson\020\234\001\022\016\n\tNullEQ"
      "Int\020\240\001\022\017\n\nNullEQReal\020\241\001\022\022\n\rNullEQDecimal"
      "\020\242\001\022\021\n\014NullEQString\020\243\001\022\017\n\nNullEQTime\020\244\001\022"
      "\023\n\016NullEQDuration\020\245\001\022\017\n\nNullEQJson\020\246\001\022\r\n"
      "\010PlusReal\020\310\001\022\020\n\013PlusDecimal\020\311\001\022\014\n\007PlusIn"
      "t\020\313\001\022\016\n\tMinusReal\020\314\001\022\021\n\014MinusDecimal\020\315\001\022"
      "\r\n\010MinusInt\020\317\001\022\021\n\014MultiplyReal\020\320\001\022\024\n\017Mul"
      "tiplyDecimal\020\321\001\022\020\n\013MultiplyInt\020\322\001\022\017\n\nDiv"
      "ideReal\020\323\001\022\022\n\rDivideDecimal\020\324\001\022\021\n\014IntDiv"
      "ideInt\020\325\001\022\025\n\020IntDivideDecimal\020\326\001\022\014\n\007ModR"
      "eal\020\327\001\022\017\n\nModDecimal\020\330\001\022\013\n\006ModInt\020\331\001\022\030\n\023"
      "MultiplyIntUnsigned\020\332\001\022\013\n\006AbsInt\020\265\020\022\014\n\007A"
      "bsUInt\020\266\020\022\014\n\007AbsReal\020\267\020\022\017\n\nAbsDecimal\020\270\020"
      "\022\021\n\014CeilIntToDec\020\271\020\022\021\n\014CeilIntToInt\020\272\020\022\021"
      "\n\014CeilDecToInt\020\273\020\022\021\n\014CeilDecToDec\020\274\020\022\r\n\010"
      "CeilReal\020\275\020\022\022\n\rFloorIntToDec\020\276\020\022\022\n\rFloor"
      "IntToInt\020\277\020\022\022\n\rFloorDecToInt\020\300\020\022\022\n\rFloor"
      "DecToDec\020\301\020\022\016\n\tFloorReal\020\302\020\022\016\n\tRoundReal"
      "\020\311\020\022\r\n\010RoundInt\020\312\020\022\r\n\010RoundDec\020\313\020\022\026\n\021Rou"
      "ndWithFracReal\020\314\020\022\025\n\020RoundWithFracInt\020\315\020"
      "\022\025\n\020RoundWithFracDec\020\316\020\022\014\n\007Log1Arg\020\323\020\022\r\n"
      "\010Log2Args\020\324\020\022\t\n\004Log2\020\325\020\022\n\n\005Log10\020\326\020\022\t\n\004R"
      "and\020\327\020\022\021\n\014RandWithSeed\020\330\020\022\010\n\003Pow\020\331\020\022\t\n\004C"
      "onv\020\332\020\022\n\n\005CRC32\020\333\020\022\t\n\004Sign\020\334\020\022\t\n\004Sqrt\020\335\020"
      "\022\t\n\004Acos\020\336\020\022\t\n\004Asin\020\337\020\022\r\n\010Atan1Arg\020\340\020\022\016\n"
      "\tAtan2Args\020\341\020\022\010\n\003Cos\020\342\020\022\010\n\003Cot\020\343\020\022\014\n\007Deg"
      "rees\020\344\020\022\010\n\003Exp\020\345\020\022\007\n\002PI\020\346\020\022\014\n\007Radians\020\347\020"
      "\022\010\n\003Sin\020\350\020\022\010\n\003Tan\020\351\020\022\020\n\013TruncateInt\020\352\020\022\021"
      "\n\014TruncateReal\020\353\020\022\024\n\017TruncateDecimal\020\354\020\022"
      "\017\n\nLogicalAnd\020\235\030\022\016\n\tLogicalOr\020\236\030\022\017\n\nLogi"
      "calXor\020\237\030\022\020\n\013UnaryNotInt\020\240\030\022\024\n\017UnaryNotD"
      "ecimal\020\241\030\022\021\n\014UnaryNotReal\020\242\030\022\022\n\rUnaryMin"
      "usInt\020\244\030\022\023\n\016UnaryMinusReal\020\245\030\022\026\n\021UnaryMi"
      "nusDecimal\020\246\030\022\022\n\rDecimalIsNull\020\247\030\022\023\n\016Dur"
      "ationIsNull\020\250\030\022\017\n\nRealIsNull\020\251\030\022\021\n\014Strin"
      "gIsNull\020\252\030\022\017\n\nTimeIsNull\020\253\030\022\016\n\tIntIsNull"
      "\020\254\030\022\017\n\nJsonIsNull\020\255\030\022\016\n\tBitAndSig\020\256\030\022\r\n\010"
      "BitOrSig\020\257\030\022\016\n\tBitXorSig\020\260\030\022\016\n\tBitNegSig"
      "\020\261\030\022\016\n\tIntIsTrue\020\262\030\022\017\n\nRealIsTrue\020\263\030\022\022\n\r"
      "DecimalIsTrue\020\264\030\022\017\n\nIntIsFalse\020\265\030\022\020\n\013Rea"
      "lIsFalse\020\266\030\022\023\n\016DecimalIsFalse\020\267\030\022\016\n\tLeft"
      "Shift\020\271\030\022\017\n\nRightShift\020\272\030\022\r\n\010BitCount\020\270\030"
      "\022\023\n\016GetParamString\020\273\030\022\013\n\006GetVar\020\274\030\022\013\n\006Ro"
      "wSig\020\275\030\022\013\n\006SetVar\020\276\030\022\022\n\rValuesDecimal\020\277\030"
      "\022\023\n\016ValuesDuration\020\300\030\022\016\n\tValuesInt\020\301\030\022\017\n"
      "\nValuesJSON\020\302\030\022\017\n\nValuesReal\020\303\030\022\021\n\014Value"
      "sString\020\304\030\022\017\n\nValuesTime\020\305\030\022\n\n\005InInt\020\241\037\022"
      "\013\n\006InReal\020\242\037\022\016\n\tInDecimal\020\243\037\022\r\n\010InString"
      "\020\244\037\022\013\n\006InTime\020\245\037\022\017\n\nInDuration\020\246\037\022\013\n\006InJ"
      "son\020\247\037\022\016\n\tIfNullInt\020\205 \022\017\n\nIfNullReal\020\206 \022"
      "\022\n\rIfNullDecimal\020\207 \022\021\n\014IfNullString\020\210 \022\017"
      "\n\nIfNullTime\020\211 \022\023\n\016IfNullDuration\020\212 \022\n\n\005"
      "IfInt\020\213 \022\013\n\006IfReal\020\214 \022\016\n\tIfDecimal\020\215 \022\r\n"
      "\010IfString\020\216 \022\013\n\006IfTime\020\217 \022\017\n\nIfDuration\020"
      "\220 \022\017\n\nIfNullJson\020\221 \022\013\n\006IfJson\020\222 \022\020\n\013Case"
      "WhenInt\020\360 \022\021\n\014CaseWhenReal\020\361 \022\024\n\017CaseWhe"
      "nDecimal\020\362 \022\023\n\016CaseWhenString\020\363 \022\021\n\014Case"
      "WhenTime\020\364 \022\025\n\020CaseWhenDuration\020\365 \022\021\n\014Ca"
      "seWhenJson\020\366 \022\017\n\nAesDecrypt\020\225#\022\017\n\nAesEnc"
      "rypt\020\226#\022\r\n\010Compress\020\227#\022\010\n\003MD5\020\230#\022\r\n\010Pass"
      "word\020\231#\022\020\n\013RandomBytes\020\232#\022\t\n\004SHA1\020\233#\022\t\n\004"
      "SHA2\020\234#\022\017\n\nUncompress\020\235#\022\027\n\022Uncompressed"
      "Length\020\236#\022\r\n\010Database\020\251#\022\016\n\tFoundRows\020\252#"
      "\022\020\n\013CurrentUser\020\253#\022\t\n\004User\020\254#\022\021\n\014Connect"
      "ionID\020\255#\022\021\n\014LastInsertID\020\256#\022\027\n\022LastInser"
      "tIDWithID\020\257#\022\014\n\007Version\020\260#\022\020\n\013TiDBVersio"
      "n\020\261#\022\r\n\010RowCount\020\262#\022\n\n\005Sleep\020\307#\022\t\n\004Lock\020"
      "\310#\022\020\n\013ReleaseLock\020\311#\022\024\n\017DecimalAnyValue\020"
      "\312#\022\025\n\020DurationAnyValue\020\313#\022\020\n\013IntAnyValue"
      "\020\314#\022\021\n\014JSONAnyValue\020\315#\022\021\n\014RealAnyValue\020\316"
      "#\022\023\n\016StringAnyValue\020\317#\022\021\n\014TimeAnyValue\020\320"
      "#\022\r\n\010InetAton\020\321#\022\r\n\010InetNtoa\020\322#\022\016\n\tInet6"
      "Aton\020\323#\022\016\n\tInet6Ntoa\020\324#\022\013\n\006IsIPv4\020\325#\022\021\n\014"
      "IsIPv4Compat\020\326#\022\021\n\014IsIPv4Mapped\020\327#\022\013\n\006Is"
      "IPv6\020\330#\022\t\n\004UUID\020\331#\022\014\n\007LikeSig\020\326!\022\024\n\017Rege"
      "xpBinarySig\020\327!\022\016\n\tRegexpSig\020\330!\022\023\n\016JsonEx"
      "tractSig\020\211\'\022\023\n\016JsonUnquoteSig\020\212\'\022\020\n\013Json"
      "TypeSig\020\213\'\022\017\n\nJsonSetSig\020\214\'\022\022\n\rJsonInser"
      "tSig\020\215\'\022\023\n\016JsonReplaceSig\020\216\'\022\022\n\rJsonRemo"
      "veSig\020\217\'\022\021\n\014JsonMergeSig\020\220\'\022\022\n\rJsonObjec"
      "tSig\020\221\'\022\021\n\014JsonArraySig\020\222\'\022\025\n\020JsonValidJ"
      "sonSig\020\223\'\022\024\n\017JsonContainsSig\020\224\'\022\027\n\022JsonA"
      "rrayAppendSig\020\225\'\022\027\n\022JsonArrayInsertSig\020\226"
      "\'\022\026\n\021JsonMergePatchSig\020\227\'\022\031\n\024JsonMergePr"
      "eserveSig\020\230\'\022\030\n\023JsonContainsPathSig\020\231\'\022\022"
      "\n\rJsonPrettySig\020\232\'\022\021\n\014JsonQuoteSig\020\233\'\022\022\n"
      "\rJsonSearchSig\020\234\'\022\027\n\022JsonStorageSizeSig\020"
      "\235\'\022\021\n\014JsonDepthSig\020\236\'\022\020\n\013JsonKeysSig\020\237\'\022"
      "\022\n\rJsonLengthSig\020\240\'\022\025\n\020JsonKeys2ArgsSig\020"
      "\241\'\022\027\n\022JsonValidStringSig\020\242\'\022\027\n\022JsonValid"
      "OthersSig\020\243\'\022\022\n\rDateFormatSig\020\361.\022\020\n\013Date"
      "Literal\020\362.\022\r\n\010DateDiff\020\363.\022\021\n\014NullTimeDif"
      "f\020\364.\022\027\n\022TimeStringTimeDiff\020\365.\022\033\n\026Duratio"
      "nStringTimeDiff\020\366.\022\035\n\030DurationDurationTi"
      "meDiff\020\367.\022\027\n\022StringTimeTimeDiff\020\370.\022\033\n\026St"
      "ringDurationTimeDiff\020\371.\022\031\n\024StringStringT"
      "imeDiff\020\372.\022\025\n\020TimeTimeTimeDiff\020\373.\022\t\n\004Dat"
      "e\020\374.\022\t\n\004Hour\020\375.\022\013\n\006Minute\020\376.\022\013\n\006Second\020\377"
      ".\022\020\n\013MicroSecond\020\200/\022\n\n\005Month\020\201/\022\016\n\tMonth"
      "Name\020\202/\022\017\n\nNowWithArg\020\203/\022\022\n\rNowWithoutAr"
      "g\020\204/\022\014\n\007DayName\020\205/\022\017\n\nDayOfMonth\020\206/\022\016\n\tD"
      "ayOfWeek\020\207/\022\016\n\tDayOfYear\020\210/\022\021\n\014WeekWithM"
      "ode\020\211/\022\024\n\017WeekWithoutMode\020\212/\022\014\n\007WeekDay\020"
      "\213/\022\017\n\nWeekOfYear\020\214/\022\t\n\004Year\020\215/\022\025\n\020YearWe"
      "ekWithMode\020\216/\022\030\n\023YearWeekWithoutMode\020\217/\022"
      "\016\n\tGetFormat\020\220/\022\023\n\016SysDateWithFsp\020\221/\022\026\n\021"
      "SysDateWithoutFsp\020\222/\022\020\n\013CurrentDate\020\223/\022\024"
      "\n\017CurrentTime0Arg\020\224/\022\024\n\017CurrentTime1Arg\020"
      "\225/\022\t\n\004Time\020\226/\022\020\n\013TimeLiteral\020\227/\022\014\n\007UTCDa"
      "te\020\230/\022\030\n\023UTCTimestampWithArg\020\231/\022\033\n\026UTCTi"
      "mestampWithoutArg\020\232/\022\033\n\026AddDatetimeAndDu"
      "ration\020\233/\022\031\n\024AddDatetimeAndString\020\234/\022\030\n\023"
      "AddTimeDateTimeNull\020\235/\022\031\n\024AddStringAndDu"
      "ration\020\236/\022\027\n\022AddStringAndString\020\237/\022\026\n\021Ad"
      "dTimeStringNull\020\240/\022\033\n\026AddDurationAndDura"
      "tion\020\241/\022\031\n\024AddDurationAndString\020\242/\022\030\n\023Ad"
      "dTimeDurationNull\020\243/\022\027\n\022AddDateAndDurati"
      "on\020\244/\022\025\n\020AddDateAndString\020\245/\022\033\n\026SubDatet"
      "imeAndDuration\020\246/\022\031\n\024SubDatetimeAndStrin"
      "g\020\247/\022\030\n\023SubTimeDateTimeNull\020\250/\022\031\n\024SubStr"
      "ingAndDuration\020\251/\022\027\n\022SubStringAndString\020"
      "\252/\022\026\n\021SubTimeStringNull\020\253/\022\033\n\026SubDuratio"
      "nAndDuration\020\254/\022\031\n\024SubDurationAndString\020"
      "\255/\022\030\n\023SubTimeDurationNull\020\256/\022\027\n\022SubDateA"
      "ndDuration\020\257/\022\025\n\020SubDateAndString\020\260/\022\031\n\024"
      "UnixTimestampCurrent\020\261/\022\025\n\020UnixTimestamp"
      "Int\020\262/\022\025\n\020UnixTimestampDec\020\263/\022\016\n\tConvert"
      "Tz\020\264/\022\r\n\010MakeDate\020\265/\022\r\n\010MakeTime\020\266/\022\016\n\tP"
      "eriodAdd\020\267/\022\017\n\nPeriodDiff\020\270/\022\014\n\007Quarter\020"
      "\271/\022\016\n\tSecToTime\020\272/\022\016\n\tTimeToSec\020\273/\022\021\n\014Ti"
      "mestampAdd\020\274/\022\013\n\006ToDays\020\275/\022\016\n\tToSeconds\020"
      "\276/\022\023\n\016UTCTimeWithArg\020\277/\022\026\n\021UTCTimeWithou"
      "tArg\020\300/\022\022\n\rTimestamp1Arg\020\301/\022\023\n\016Timestamp"
      "2Args\020\302/\022\025\n\020TimestampLiteral\020\303/\022\014\n\007LastD"
      "ay\020\304/\022\022\n\rStrToDateDate\020\305/\022\026\n\021StrToDateDa"
      "tetime\020\306/\022\026\n\021StrToDateDuration\020\307/\022\025\n\020Fro"
      "mUnixTime1Arg\020\310/\022\025\n\020FromUnixTime2Arg\020\311/\022"
      "\024\n\017ExtractDatetime\020\312/\022\024\n\017ExtractDuration"
      "\020\313/\022\030\n\023AddDateStringString\020\314/\022\025\n\020AddDate"
      "StringInt\020\315/\022\031\n\024AddDateStringDecimal\020\316/\022"
      "\025\n\020AddDateIntString\020\317/\022\022\n\rAddDateIntInt\020"
      "\320/\022\032\n\025AddDateDatetimeString\020\321/\022\027\n\022AddDat"
      "eDatetimeInt\020\322/\022\030\n\023SubDateStringString\020\323"
      "/\022\025\n\020SubDateStringInt\020\324/\022\031\n\024SubDateStrin"
      "gDecimal\020\325/\022\025\n\020SubDateIntString\020\326/\022\022\n\rSu"
      "bDateIntInt\020\327/\022\032\n\025SubDateDatetimeString\020"
      "\330/\022\027\n\022SubDateDatetimeInt\020\331/\022\r\n\010FromDays\020"
      "\332/\022\017\n\nTimeFormat\020\333/\022\022\n\rTimestampDiff\020\334/\022"
      "\016\n\tBitLength\020\3316\022\010\n\003Bin\020\3326\022\n\n\005ASCII\020\3336\022\t\n"
      "\004Char\020\3346\022\017\n\nCharLength\020\3356\022\013\n\006Concat\020\3366\022\r"
      "\n\010ConcatWS\020\3376\022\014\n\007Convert\020\3406\022\010\n\003Elt\020\3416\022\022\n"
      "\rExportSet3Arg\020\3426\022\022\n\rExportSet4Arg\020\3436\022\022\n"
      "\rExportSet5Arg\020\3446\022\r\n\010FieldInt\020\3456\022\016\n\tFiel"
      "dReal\020\3466\022\020\n\013FieldString\020\3476\022\016\n\tFindInSet\020"
      "\3506\022\013\n\006Format\020\3516\022\025\n\020FormatWithLocale\020\3526\022\017"
      "\n\nFromBase64\020\3536\022\016\n\tHexIntArg\020\3546\022\016\n\tHexSt"
      "rArg\020\3556\022\013\n\006Insert\020\3566\022\021\n\014InsertBinary\020\3576\022"
      "\n\n\005Instr\020\3606\022\020\n\013InstrBinary\020\3616\022\n\n\005LTrim\020\362"
      "6\022\t\n\004Left\020\3636\022\017\n\nLeftBinary\020\3646\022\013\n\006Length\020"
      "\3656\022\020\n\013Locate2Args\020\3666\022\020\n\013Locate3Args\020\3676\022\026"
      "\n\021LocateBinary2Args\020\3706\022\026\n\021LocateBinary3A"
      "rgs\020\3716\022\n\n\005Lower\020\3726\022\t\n\004Lpad\020\3736\022\017\n\nLpadBin"
      "ary\020\3746\022\014\n\007MakeSet\020\3756\022\013\n\006OctInt\020\3766\022\016\n\tOct"
      "String\020\3776\022\010\n\003Ord\020\2007\022\n\n\005Quote\020\2017\022\n\n\005RTrim"
      "\020\2027\022\013\n\006Repeat\020\2037\022\014\n\007Replace\020\2047\022\014\n\007Revers"
      "e\020\2057\022\022\n\rReverseBinary\020\2067\022\n\n\005Right\020\2077\022\020\n\013"
      "RightBinary\020\2107\022\t\n\004Rpad\020\2117\022\017\n\nRpadBinary\020"
      "\2127\022\n\n\005Space\020\2137\022\013\n\006Strcmp\020\2147\022\023\n\016Substring"
      "2Args\020\2157\022\023\n\016Substring3Args\020\2167\022\031\n\024Substri"
      "ngBinary2Args\020\2177\022\031\n\024SubstringBinary3Args"
      "\020\2207\022\023\n\016SubstringIndex\020\2217\022\r\n\010ToBase64\020\2227\022"
      "\r\n\010Trim1Arg\020\2237\022\016\n\tTrim2Args\020\2247\022\016\n\tTrim3A"
      "rgs\020\2257\022\n\n\005UnHex\020\2267\022\n\n\005Upper\020\2277B\031\n\025com.pi"
      "ngcap.tidb.tipbP\001"
  };
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
      descriptor, 9817);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "expression.proto", &protobuf_RegisterTypes);
}

void AddDescriptors() {
  static GOOGLE_PROTOBUF_DECLARE_ONCE(once);
  ::google::protobuf::GoogleOnceInit(&once, &AddDescriptorsImpl);
}
// Force AddDescriptors() to be called at dynamic initialization time.
struct StaticDescriptorInitializer {
  StaticDescriptorInitializer() {
    AddDescriptors();
  }
} static_descriptor_initializer;
}  // namespace protobuf_expression_2eproto
namespace tipb {
const ::google::protobuf::EnumDescriptor* ExprType_descriptor() {
  protobuf_expression_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_expression_2eproto::file_level_enum_descriptors[0];
}
bool ExprType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 151:
    case 201:
    case 3001:
    case 3002:
    case 3003:
    case 3004:
    case 3005:
    case 3006:
    case 3007:
    case 3008:
    case 3009:
    case 3010:
    case 3011:
    case 3012:
    case 3013:
    case 3014:
    case 3015:
    case 3016:
    case 3017:
    case 3018:
    case 3019:
    case 10000:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ScalarFuncSig_descriptor() {
  protobuf_expression_2eproto::protobuf_AssignDescriptorsOnce();
  return protobuf_expression_2eproto::file_level_enum_descriptors[1];
}
bool ScalarFuncSig_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
    case 145:
    case 146:
    case 150:
    case 151:
    case 152:
    case 153:
    case 154:
    case 155:
    case 156:
    case 160:
    case 161:
    case 162:
    case 163:
    case 164:
    case 165:
    case 166:
    case 200:
    case 201:
    case 203:
    case 204:
    case 205:
    case 207:
    case 208:
    case 209:
    case 210:
    case 211:
    case 212:
    case 213:
    case 214:
    case 215:
    case 216:
    case 217:
    case 218:
    case 2101:
    case 2102:
    case 2103:
    case 2104:
    case 2105:
    case 2106:
    case 2107:
    case 2108:
    case 2109:
    case 2110:
    case 2111:
    case 2112:
    case 2113:
    case 2114:
    case 2121:
    case 2122:
    case 2123:
    case 2124:
    case 2125:
    case 2126:
    case 2131:
    case 2132:
    case 2133:
    case 2134:
    case 2135:
    case 2136:
    case 2137:
    case 2138:
    case 2139:
    case 2140:
    case 2141:
    case 2142:
    case 2143:
    case 2144:
    case 2145:
    case 2146:
    case 2147:
    case 2148:
    case 2149:
    case 2150:
    case 2151:
    case 2152:
    case 2153:
    case 2154:
    case 2155:
    case 2156:
    case 3101:
    case 3102:
    case 3103:
    case 3104:
    case 3105:
    case 3106:
    case 3108:
    case 3109:
    case 3110:
    case 3111:
    case 3112:
    case 3113:
    case 3114:
    case 3115:
    case 3116:
    case 3117:
    case 3118:
    case 3119:
    case 3120:
    case 3121:
    case 3122:
    case 3123:
    case 3124:
    case 3125:
    case 3126:
    case 3127:
    case 3128:
    case 3129:
    case 3130:
    case 3131:
    case 3132:
    case 3133:
    case 3134:
    case 3135:
    case 3136:
    case 3137:
    case 3138:
    case 3139:
    case 3140:
    case 3141:
    case 4001:
    case 4002:
    case 4003:
    case 4004:
    case 4005:
    case 4006:
    case 4007:
    case 4101:
    case 4102:
    case 4103:
    case 4104:
    case 4105:
    case 4106:
    case 4107:
    case 4108:
    case 4109:
    case 4110:
    case 4111:
    case 4112:
    case 4113:
    case 4114:
    case 4201:
    case 4202:
    case 4203:
    case 4204:
    case 4205:
    case 4206:
    case 4207:
    case 4208:
    case 4209:
    case 4210:
    case 4211:
    case 4212:
    case 4213:
    case 4214:
    case 4215:
    case 4216:
    case 4217:
    case 4218:
    case 4219:
    case 4220:
    case 4221:
    case 4222:
    case 4223:
    case 4224:
    case 4225:
    case 4226:
    case 4310:
    case 4311:
    case 4312:
    case 4501:
    case 4502:
    case 4503:
    case 4504:
    case 4505:
    case 4506:
    case 4507:
    case 4508:
    case 4509:
    case 4510:
    case 4521:
    case 4522:
    case 4523:
    case 4524:
    case 4525:
    case 4526:
    case 4527:
    case 4528:
    case 4529:
    case 4530:
    case 4551:
    case 4552:
    case 4553:
    case 4554:
    case 4555:
    case 4556:
    case 4557:
    case 4558:
    case 4559:
    case 4560:
    case 4561:
    case 4562:
    case 4563:
    case 4564:
    case 4565:
    case 4566:
    case 4567:
    case 4568:
    case 4569:
    case 5001:
    case 5002:
    case 5003:
    case 5004:
    case 5005:
    case 5006:
    case 5007:
    case 5008:
    case 5009:
    case 5010:
    case 5011:
    case 5012:
    case 5013:
    case 5014:
    case 5015:
    case 5016:
    case 5017:
    case 5018:
    case 5019:
    case 5020:
    case 5021:
    case 5022:
    case 5023:
    case 5024:
    case 5025:
    case 5026:
    case 5027:
    case 6001:
    case 6002:
    case 6003:
    case 6004:
    case 6005:
    case 6006:
    case 6007:
    case 6008:
    case 6009:
    case 6010:
    case 6011:
    case 6012:
    case 6013:
    case 6014:
    case 6015:
    case 6016:
    case 6017:
    case 6018:
    case 6019:
    case 6020:
    case 6021:
    case 6022:
    case 6023:
    case 6024:
    case 6025:
    case 6026:
    case 6027:
    case 6028:
    case 6029:
    case 6030:
    case 6031:
    case 6032:
    case 6033:
    case 6034:
    case 6035:
    case 6036:
    case 6037:
    case 6038:
    case 6039:
    case 6040:
    case 6041:
    case 6042:
    case 6043:
    case 6044:
    case 6045:
    case 6046:
    case 6047:
    case 6048:
    case 6049:
    case 6050:
    case 6051:
    case 6052:
    case 6053:
    case 6054:
    case 6055:
    case 6056:
    case 6057:
    case 6058:
    case 6059:
    case 6060:
    case 6061:
    case 6062:
    case 6063:
    case 6064:
    case 6065:
    case 6066:
    case 6067:
    case 6068:
    case 6069:
    case 6070:
    case 6071:
    case 6072:
    case 6073:
    case 6074:
    case 6075:
    case 6076:
    case 6077:
    case 6078:
    case 6079:
    case 6080:
    case 6081:
    case 6082:
    case 6083:
    case 6084:
    case 6085:
    case 6086:
    case 6087:
    case 6088:
    case 6089:
    case 6090:
    case 6091:
    case 6092:
    case 6093:
    case 6094:
    case 6095:
    case 6096:
    case 6097:
    case 6098:
    case 6099:
    case 6100:
    case 6101:
    case 6102:
    case 6103:
    case 6104:
    case 6105:
    case 6106:
    case 6107:
    case 6108:
    case 7001:
    case 7002:
    case 7003:
    case 7004:
    case 7005:
    case 7006:
    case 7007:
    case 7008:
    case 7009:
    case 7010:
    case 7011:
    case 7012:
    case 7013:
    case 7014:
    case 7015:
    case 7016:
    case 7017:
    case 7018:
    case 7019:
    case 7020:
    case 7021:
    case 7022:
    case 7023:
    case 7024:
    case 7025:
    case 7026:
    case 7027:
    case 7028:
    case 7029:
    case 7030:
    case 7031:
    case 7032:
    case 7033:
    case 7034:
    case 7035:
    case 7036:
    case 7037:
    case 7038:
    case 7039:
    case 7040:
    case 7041:
    case 7042:
    case 7043:
    case 7044:
    case 7045:
    case 7046:
    case 7047:
    case 7048:
    case 7049:
    case 7050:
    case 7051:
    case 7052:
    case 7053:
    case 7054:
    case 7055:
    case 7056:
    case 7057:
    case 7058:
    case 7059:
    case 7060:
    case 7061:
    case 7062:
    case 7063:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void FieldType::InitAsDefaultInstance() {
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FieldType::kTpFieldNumber;
const int FieldType::kFlagFieldNumber;
const int FieldType::kFlenFieldNumber;
const int FieldType::kDecimalFieldNumber;
const int FieldType::kCollateFieldNumber;
const int FieldType::kCharsetFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FieldType::FieldType()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_expression_2eproto::InitDefaultsFieldType();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:tipb.FieldType)
}
FieldType::FieldType(const FieldType& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  charset_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_charset()) {
    charset_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.charset_);
  }
  ::memcpy(&tp_, &from.tp_,
    static_cast<size_t>(reinterpret_cast<char*>(&collate_) -
    reinterpret_cast<char*>(&tp_)) + sizeof(collate_));
  // @@protoc_insertion_point(copy_constructor:tipb.FieldType)
}

void FieldType::SharedCtor() {
  _cached_size_ = 0;
  charset_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&tp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&collate_) -
      reinterpret_cast<char*>(&tp_)) + sizeof(collate_));
}

FieldType::~FieldType() {
  // @@protoc_insertion_point(destructor:tipb.FieldType)
  SharedDtor();
}

void FieldType::SharedDtor() {
  charset_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void FieldType::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FieldType::descriptor() {
  ::protobuf_expression_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_expression_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const FieldType& FieldType::default_instance() {
  ::protobuf_expression_2eproto::InitDefaultsFieldType();
  return *internal_default_instance();
}

FieldType* FieldType::New(::google::protobuf::Arena* arena) const {
  FieldType* n = new FieldType;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FieldType::Clear() {
// @@protoc_insertion_point(message_clear_start:tipb.FieldType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(!charset_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
    (*charset_.UnsafeRawStringPointer())->clear();
  }
  if (cached_has_bits & 62u) {
    ::memset(&tp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&collate_) -
        reinterpret_cast<char*>(&tp_)) + sizeof(collate_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool FieldType::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tipb.FieldType)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 tp = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          set_has_tp();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &tp_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 flag = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_flag();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flag_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 flen = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(24u /* 24 & 0xFF */)) {
          set_has_flen();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &flen_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 decimal = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          set_has_decimal();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &decimal_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional int32 collate = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(40u /* 40 & 0xFF */)) {
          set_has_collate();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &collate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string charset = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(50u /* 50 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_charset()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->charset().data(), static_cast<int>(this->charset().length()),
            ::google::protobuf::internal::WireFormat::PARSE,
            "tipb.FieldType.charset");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tipb.FieldType)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tipb.FieldType)
  return false;
#undef DO_
}

void FieldType::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tipb.FieldType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 tp = 1;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->tp(), output);
  }

  // optional uint32 flag = 2;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->flag(), output);
  }

  // optional int32 flen = 3;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->flen(), output);
  }

  // optional int32 decimal = 4;
  if (cached_has_bits & 0x00000010u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->decimal(), output);
  }

  // optional int32 collate = 5;
  if (cached_has_bits & 0x00000020u) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->collate(), output);
  }

  // optional string charset = 6;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->charset().data(), static_cast<int>(this->charset().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "tipb.FieldType.charset");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->charset(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tipb.FieldType)
}

::google::protobuf::uint8* FieldType::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tipb.FieldType)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 tp = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->tp(), target);
  }

  // optional uint32 flag = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->flag(), target);
  }

  // optional int32 flen = 3;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->flen(), target);
  }

  // optional int32 decimal = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->decimal(), target);
  }

  // optional int32 collate = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->collate(), target);
  }

  // optional string charset = 6;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->charset().data(), static_cast<int>(this->charset().length()),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "tipb.FieldType.charset");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->charset(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tipb.FieldType)
  return target;
}

size_t FieldType::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tipb.FieldType)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 63u) {
    // optional string charset = 6;
    if (has_charset()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->charset());
    }

    // optional int32 tp = 1;
    if (has_tp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->tp());
    }

    // optional uint32 flag = 2;
    if (has_flag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flag());
    }

    // optional int32 flen = 3;
    if (has_flen()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->flen());
    }

    // optional int32 decimal = 4;
    if (has_decimal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->decimal());
    }

    // optional int32 collate = 5;
    if (has_collate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->collate());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FieldType::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tipb.FieldType)
  GOOGLE_DCHECK_NE(&from, this);
  const FieldType* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const FieldType>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tipb.FieldType)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tipb.FieldType)
    MergeFrom(*source);
  }
}

void FieldType::MergeFrom(const FieldType& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tipb.FieldType)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 63u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_charset();
      charset_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.charset_);
    }
    if (cached_has_bits & 0x00000002u) {
      tp_ = from.tp_;
    }
    if (cached_has_bits & 0x00000004u) {
      flag_ = from.flag_;
    }
    if (cached_has_bits & 0x00000008u) {
      flen_ = from.flen_;
    }
    if (cached_has_bits & 0x00000010u) {
      decimal_ = from.decimal_;
    }
    if (cached_has_bits & 0x00000020u) {
      collate_ = from.collate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void FieldType::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tipb.FieldType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FieldType::CopyFrom(const FieldType& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tipb.FieldType)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FieldType::IsInitialized() const {
  return true;
}

void FieldType::Swap(FieldType* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FieldType::InternalSwap(FieldType* other) {
  using std::swap;
  charset_.Swap(&other->charset_);
  swap(tp_, other->tp_);
  swap(flag_, other->flag_);
  swap(flen_, other->flen_);
  swap(decimal_, other->decimal_);
  swap(collate_, other->collate_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FieldType::GetMetadata() const {
  protobuf_expression_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_expression_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void Expr::InitAsDefaultInstance() {
  ::tipb::_Expr_default_instance_._instance.get_mutable()->field_type_ = const_cast< ::tipb::FieldType*>(
      ::tipb::FieldType::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Expr::kTpFieldNumber;
const int Expr::kValFieldNumber;
const int Expr::kChildrenFieldNumber;
const int Expr::kSigFieldNumber;
const int Expr::kFieldTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Expr::Expr()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_expression_2eproto::InitDefaultsExpr();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:tipb.Expr)
}
Expr::Expr(const Expr& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0),
      children_(from.children_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.has_val()) {
    val_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.val_);
  }
  if (from.has_field_type()) {
    field_type_ = new ::tipb::FieldType(*from.field_type_);
  } else {
    field_type_ = NULL;
  }
  ::memcpy(&tp_, &from.tp_,
    static_cast<size_t>(reinterpret_cast<char*>(&sig_) -
    reinterpret_cast<char*>(&tp_)) + sizeof(sig_));
  // @@protoc_insertion_point(copy_constructor:tipb.Expr)
}

void Expr::SharedCtor() {
  _cached_size_ = 0;
  val_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&field_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&sig_) -
      reinterpret_cast<char*>(&field_type_)) + sizeof(sig_));
}

Expr::~Expr() {
  // @@protoc_insertion_point(destructor:tipb.Expr)
  SharedDtor();
}

void Expr::SharedDtor() {
  val_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete field_type_;
}

void Expr::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Expr::descriptor() {
  ::protobuf_expression_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_expression_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const Expr& Expr::default_instance() {
  ::protobuf_expression_2eproto::InitDefaultsExpr();
  return *internal_default_instance();
}

Expr* Expr::New(::google::protobuf::Arena* arena) const {
  Expr* n = new Expr;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Expr::Clear() {
// @@protoc_insertion_point(message_clear_start:tipb.Expr)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  children_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(!val_.IsDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited()));
      (*val_.UnsafeRawStringPointer())->clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(field_type_ != NULL);
      field_type_->Clear();
    }
  }
  if (cached_has_bits & 12u) {
    ::memset(&tp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&sig_) -
        reinterpret_cast<char*>(&tp_)) + sizeof(sig_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool Expr::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tipb.Expr)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .tipb.ExprType tp = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(8u /* 8 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tipb::ExprType_IsValid(value)) {
            set_tp(static_cast< ::tipb::ExprType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes val = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(18u /* 18 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_val()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .tipb.Expr children = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(26u /* 26 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(input, add_children()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .tipb.ScalarFuncSig sig = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(32u /* 32 & 0xFF */)) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::tipb::ScalarFuncSig_IsValid(value)) {
            set_sig(static_cast< ::tipb::ScalarFuncSig >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast< ::google::protobuf::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .tipb.FieldType field_type = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(42u /* 42 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_field_type()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tipb.Expr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tipb.Expr)
  return false;
#undef DO_
}

void Expr::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tipb.Expr)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tipb.ExprType tp = 1;
  if (cached_has_bits & 0x00000004u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->tp(), output);
  }

  // optional bytes val = 2;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->val(), output);
  }

  // repeated .tipb.Expr children = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->children_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->children(static_cast<int>(i)), output);
  }

  // optional .tipb.ScalarFuncSig sig = 4;
  if (cached_has_bits & 0x00000008u) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->sig(), output);
  }

  // optional .tipb.FieldType field_type = 5;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->field_type_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tipb.Expr)
}

::google::protobuf::uint8* Expr::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tipb.Expr)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tipb.ExprType tp = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->tp(), target);
  }

  // optional bytes val = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->val(), target);
  }

  // repeated .tipb.Expr children = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->children_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, this->children(static_cast<int>(i)), deterministic, target);
  }

  // optional .tipb.ScalarFuncSig sig = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->sig(), target);
  }

  // optional .tipb.FieldType field_type = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, *this->field_type_, deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tipb.Expr)
  return target;
}

size_t Expr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tipb.Expr)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // repeated .tipb.Expr children = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->children_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->children(static_cast<int>(i)));
    }
  }

  if (_has_bits_[0 / 32] & 15u) {
    // optional bytes val = 2;
    if (has_val()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->val());
    }

    // optional .tipb.FieldType field_type = 5;
    if (has_field_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->field_type_);
    }

    // optional .tipb.ExprType tp = 1;
    if (has_tp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->tp());
    }

    // optional .tipb.ScalarFuncSig sig = 4;
    if (has_sig()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->sig());
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Expr::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tipb.Expr)
  GOOGLE_DCHECK_NE(&from, this);
  const Expr* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const Expr>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tipb.Expr)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tipb.Expr)
    MergeFrom(*source);
  }
}

void Expr::MergeFrom(const Expr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tipb.Expr)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  children_.MergeFrom(from.children_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 15u) {
    if (cached_has_bits & 0x00000001u) {
      set_has_val();
      val_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.val_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_field_type()->::tipb::FieldType::MergeFrom(from.field_type());
    }
    if (cached_has_bits & 0x00000004u) {
      tp_ = from.tp_;
    }
    if (cached_has_bits & 0x00000008u) {
      sig_ = from.sig_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Expr::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tipb.Expr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Expr::CopyFrom(const Expr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tipb.Expr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Expr::IsInitialized() const {
  return true;
}

void Expr::Swap(Expr* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Expr::InternalSwap(Expr* other) {
  using std::swap;
  children_.InternalSwap(&other->children_);
  val_.Swap(&other->val_);
  swap(field_type_, other->field_type_);
  swap(tp_, other->tp_);
  swap(sig_, other->sig_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Expr::GetMetadata() const {
  protobuf_expression_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_expression_2eproto::file_level_metadata[kIndexInFileMessages];
}


// ===================================================================

void ByItem::InitAsDefaultInstance() {
  ::tipb::_ByItem_default_instance_._instance.get_mutable()->expr_ = const_cast< ::tipb::Expr*>(
      ::tipb::Expr::internal_default_instance());
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ByItem::kExprFieldNumber;
const int ByItem::kDescFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ByItem::ByItem()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (GOOGLE_PREDICT_TRUE(this != internal_default_instance())) {
    ::protobuf_expression_2eproto::InitDefaultsByItem();
  }
  SharedCtor();
  // @@protoc_insertion_point(constructor:tipb.ByItem)
}
ByItem::ByItem(const ByItem& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      _has_bits_(from._has_bits_),
      _cached_size_(0) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_expr()) {
    expr_ = new ::tipb::Expr(*from.expr_);
  } else {
    expr_ = NULL;
  }
  desc_ = from.desc_;
  // @@protoc_insertion_point(copy_constructor:tipb.ByItem)
}

void ByItem::SharedCtor() {
  _cached_size_ = 0;
  ::memset(&expr_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&desc_) -
      reinterpret_cast<char*>(&expr_)) + sizeof(desc_));
}

ByItem::~ByItem() {
  // @@protoc_insertion_point(destructor:tipb.ByItem)
  SharedDtor();
}

void ByItem::SharedDtor() {
  if (this != internal_default_instance()) delete expr_;
}

void ByItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ByItem::descriptor() {
  ::protobuf_expression_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_expression_2eproto::file_level_metadata[kIndexInFileMessages].descriptor;
}

const ByItem& ByItem::default_instance() {
  ::protobuf_expression_2eproto::InitDefaultsByItem();
  return *internal_default_instance();
}

ByItem* ByItem::New(::google::protobuf::Arena* arena) const {
  ByItem* n = new ByItem;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ByItem::Clear() {
// @@protoc_insertion_point(message_clear_start:tipb.ByItem)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(expr_ != NULL);
    expr_->Clear();
  }
  desc_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

bool ByItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:tipb.ByItem)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .tipb.Expr expr = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(10u /* 10 & 0xFF */)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool desc = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) ==
            static_cast< ::google::protobuf::uint8>(16u /* 16 & 0xFF */)) {
          set_has_desc();
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &desc_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:tipb.ByItem)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:tipb.ByItem)
  return false;
#undef DO_
}

void ByItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:tipb.ByItem)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tipb.Expr expr = 1;
  if (cached_has_bits & 0x00000001u) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->expr_, output);
  }

  // optional bool desc = 2;
  if (cached_has_bits & 0x00000002u) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->desc(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:tipb.ByItem)
}

::google::protobuf::uint8* ByItem::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:tipb.ByItem)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tipb.Expr expr = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, *this->expr_, deterministic, target);
  }

  // optional bool desc = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->desc(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tipb.ByItem)
  return target;
}

size_t ByItem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tipb.ByItem)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional .tipb.Expr expr = 1;
    if (has_expr()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          *this->expr_);
    }

    // optional bool desc = 2;
    if (has_desc()) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ByItem::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:tipb.ByItem)
  GOOGLE_DCHECK_NE(&from, this);
  const ByItem* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const ByItem>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:tipb.ByItem)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:tipb.ByItem)
    MergeFrom(*source);
  }
}

void ByItem::MergeFrom(const ByItem& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tipb.ByItem)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 3u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_expr()->::tipb::Expr::MergeFrom(from.expr());
    }
    if (cached_has_bits & 0x00000002u) {
      desc_ = from.desc_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ByItem::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:tipb.ByItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ByItem::CopyFrom(const ByItem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tipb.ByItem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ByItem::IsInitialized() const {
  return true;
}

void ByItem::Swap(ByItem* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ByItem::InternalSwap(ByItem* other) {
  using std::swap;
  swap(expr_, other->expr_);
  swap(desc_, other->desc_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ByItem::GetMetadata() const {
  protobuf_expression_2eproto::protobuf_AssignDescriptorsOnce();
  return ::protobuf_expression_2eproto::file_level_metadata[kIndexInFileMessages];
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace tipb

// @@protoc_insertion_point(global_scope)
