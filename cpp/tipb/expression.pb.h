// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: expression.proto

#ifndef PROTOBUF_expression_2eproto__INCLUDED
#define PROTOBUF_expression_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_expression_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsFieldTypeImpl();
void InitDefaultsFieldType();
void InitDefaultsExprImpl();
void InitDefaultsExpr();
void InitDefaultsByItemImpl();
void InitDefaultsByItem();
inline void InitDefaults() {
  InitDefaultsFieldType();
  InitDefaultsExpr();
  InitDefaultsByItem();
}
}  // namespace protobuf_expression_2eproto
namespace tipb {
class ByItem;
class ByItemDefaultTypeInternal;
extern ByItemDefaultTypeInternal _ByItem_default_instance_;
class Expr;
class ExprDefaultTypeInternal;
extern ExprDefaultTypeInternal _Expr_default_instance_;
class FieldType;
class FieldTypeDefaultTypeInternal;
extern FieldTypeDefaultTypeInternal _FieldType_default_instance_;
}  // namespace tipb
namespace tipb {

enum ExprType {
  Null = 0,
  Int64 = 1,
  Uint64 = 2,
  Float32 = 3,
  Float64 = 4,
  String = 5,
  Bytes = 6,
  MysqlBit = 101,
  MysqlDecimal = 102,
  MysqlDuration = 103,
  MysqlEnum = 104,
  MysqlHex = 105,
  MysqlSet = 106,
  MysqlTime = 107,
  MysqlJson = 108,
  ValueList = 151,
  ColumnRef = 201,
  Count = 3001,
  Sum = 3002,
  Avg = 3003,
  Min = 3004,
  Max = 3005,
  First = 3006,
  GroupConcat = 3007,
  Agg_BitAnd = 3008,
  Agg_BitOr = 3009,
  Agg_BitXor = 3010,
  Std = 3011,
  Stddev = 3012,
  StddevPop = 3013,
  StddevSamp = 3014,
  VarPop = 3015,
  VarSamp = 3016,
  Variance = 3017,
  JsonArrayAgg = 3018,
  JsonObjectAgg = 3019,
  ScalarFunc = 10000
};
bool ExprType_IsValid(int value);
const ExprType ExprType_MIN = Null;
const ExprType ExprType_MAX = ScalarFunc;
const int ExprType_ARRAYSIZE = ExprType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExprType_descriptor();
inline const ::std::string& ExprType_Name(ExprType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExprType_descriptor(), value);
}
inline bool ExprType_Parse(
    const ::std::string& name, ExprType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExprType>(
    ExprType_descriptor(), name, value);
}
enum ScalarFuncSig {
  CastIntAsInt = 0,
  CastIntAsReal = 1,
  CastIntAsString = 2,
  CastIntAsDecimal = 3,
  CastIntAsTime = 4,
  CastIntAsDuration = 5,
  CastIntAsJson = 6,
  CastRealAsInt = 10,
  CastRealAsReal = 11,
  CastRealAsString = 12,
  CastRealAsDecimal = 13,
  CastRealAsTime = 14,
  CastRealAsDuration = 15,
  CastRealAsJson = 16,
  CastDecimalAsInt = 20,
  CastDecimalAsReal = 21,
  CastDecimalAsString = 22,
  CastDecimalAsDecimal = 23,
  CastDecimalAsTime = 24,
  CastDecimalAsDuration = 25,
  CastDecimalAsJson = 26,
  CastStringAsInt = 30,
  CastStringAsReal = 31,
  CastStringAsString = 32,
  CastStringAsDecimal = 33,
  CastStringAsTime = 34,
  CastStringAsDuration = 35,
  CastStringAsJson = 36,
  CastTimeAsInt = 40,
  CastTimeAsReal = 41,
  CastTimeAsString = 42,
  CastTimeAsDecimal = 43,
  CastTimeAsTime = 44,
  CastTimeAsDuration = 45,
  CastTimeAsJson = 46,
  CastDurationAsInt = 50,
  CastDurationAsReal = 51,
  CastDurationAsString = 52,
  CastDurationAsDecimal = 53,
  CastDurationAsTime = 54,
  CastDurationAsDuration = 55,
  CastDurationAsJson = 56,
  CastJsonAsInt = 60,
  CastJsonAsReal = 61,
  CastJsonAsString = 62,
  CastJsonAsDecimal = 63,
  CastJsonAsTime = 64,
  CastJsonAsDuration = 65,
  CastJsonAsJson = 66,
  CoalesceInt = 4201,
  CoalesceReal = 4202,
  CoalesceDecimal = 4203,
  CoalesceString = 4204,
  CoalesceTime = 4205,
  CoalesceDuration = 4206,
  CoalesceJson = 4207,
  LTInt = 100,
  LTReal = 101,
  LTDecimal = 102,
  LTString = 103,
  LTTime = 104,
  LTDuration = 105,
  LTJson = 106,
  LEInt = 110,
  LEReal = 111,
  LEDecimal = 112,
  LEString = 113,
  LETime = 114,
  LEDuration = 115,
  LEJson = 116,
  GTInt = 120,
  GTReal = 121,
  GTDecimal = 122,
  GTString = 123,
  GTTime = 124,
  GTDuration = 125,
  GTJson = 126,
  GreatestInt = 4215,
  GreatestReal = 4216,
  GreatestDecimal = 4217,
  GreatestString = 4218,
  GreatestTime = 4219,
  LeastInt = 4220,
  LeastReal = 4221,
  LeastDecimal = 4222,
  LeastString = 4223,
  LeastTime = 4224,
  IntervalInt = 4225,
  IntervalReal = 4226,
  GEInt = 130,
  GEReal = 131,
  GEDecimal = 132,
  GEString = 133,
  GETime = 134,
  GEDuration = 135,
  GEJson = 136,
  EQInt = 140,
  EQReal = 141,
  EQDecimal = 142,
  EQString = 143,
  EQTime = 144,
  EQDuration = 145,
  EQJson = 146,
  NEInt = 150,
  NEReal = 151,
  NEDecimal = 152,
  NEString = 153,
  NETime = 154,
  NEDuration = 155,
  NEJson = 156,
  NullEQInt = 160,
  NullEQReal = 161,
  NullEQDecimal = 162,
  NullEQString = 163,
  NullEQTime = 164,
  NullEQDuration = 165,
  NullEQJson = 166,
  PlusReal = 200,
  PlusDecimal = 201,
  PlusInt = 203,
  MinusReal = 204,
  MinusDecimal = 205,
  MinusInt = 207,
  MultiplyReal = 208,
  MultiplyDecimal = 209,
  MultiplyInt = 210,
  DivideReal = 211,
  DivideDecimal = 212,
  IntDivideInt = 213,
  IntDivideDecimal = 214,
  ModReal = 215,
  ModDecimal = 216,
  ModInt = 217,
  MultiplyIntUnsigned = 218,
  AbsInt = 2101,
  AbsUInt = 2102,
  AbsReal = 2103,
  AbsDecimal = 2104,
  CeilIntToDec = 2105,
  CeilIntToInt = 2106,
  CeilDecToInt = 2107,
  CeilDecToDec = 2108,
  CeilReal = 2109,
  FloorIntToDec = 2110,
  FloorIntToInt = 2111,
  FloorDecToInt = 2112,
  FloorDecToDec = 2113,
  FloorReal = 2114,
  RoundReal = 2121,
  RoundInt = 2122,
  RoundDec = 2123,
  RoundWithFracReal = 2124,
  RoundWithFracInt = 2125,
  RoundWithFracDec = 2126,
  Log1Arg = 2131,
  Log2Args = 2132,
  Log2 = 2133,
  Log10 = 2134,
  Rand = 2135,
  RandWithSeed = 2136,
  Pow = 2137,
  Conv = 2138,
  CRC32 = 2139,
  Sign = 2140,
  Sqrt = 2141,
  Acos = 2142,
  Asin = 2143,
  Atan1Arg = 2144,
  Atan2Args = 2145,
  Cos = 2146,
  Cot = 2147,
  Degrees = 2148,
  Exp = 2149,
  PI = 2150,
  Radians = 2151,
  Sin = 2152,
  Tan = 2153,
  TruncateInt = 2154,
  TruncateReal = 2155,
  TruncateDecimal = 2156,
  LogicalAnd = 3101,
  LogicalOr = 3102,
  LogicalXor = 3103,
  UnaryNotInt = 3104,
  UnaryNotDecimal = 3105,
  UnaryNotReal = 3106,
  UnaryMinusInt = 3108,
  UnaryMinusReal = 3109,
  UnaryMinusDecimal = 3110,
  DecimalIsNull = 3111,
  DurationIsNull = 3112,
  RealIsNull = 3113,
  StringIsNull = 3114,
  TimeIsNull = 3115,
  IntIsNull = 3116,
  JsonIsNull = 3117,
  BitAndSig = 3118,
  BitOrSig = 3119,
  BitXorSig = 3120,
  BitNegSig = 3121,
  IntIsTrue = 3122,
  RealIsTrue = 3123,
  DecimalIsTrue = 3124,
  IntIsFalse = 3125,
  RealIsFalse = 3126,
  DecimalIsFalse = 3127,
  LeftShift = 3129,
  RightShift = 3130,
  BitCount = 3128,
  GetParamString = 3131,
  GetVar = 3132,
  RowSig = 3133,
  SetVar = 3134,
  ValuesDecimal = 3135,
  ValuesDuration = 3136,
  ValuesInt = 3137,
  ValuesJSON = 3138,
  ValuesReal = 3139,
  ValuesString = 3140,
  ValuesTime = 3141,
  InInt = 4001,
  InReal = 4002,
  InDecimal = 4003,
  InString = 4004,
  InTime = 4005,
  InDuration = 4006,
  InJson = 4007,
  IfNullInt = 4101,
  IfNullReal = 4102,
  IfNullDecimal = 4103,
  IfNullString = 4104,
  IfNullTime = 4105,
  IfNullDuration = 4106,
  IfInt = 4107,
  IfReal = 4108,
  IfDecimal = 4109,
  IfString = 4110,
  IfTime = 4111,
  IfDuration = 4112,
  IfNullJson = 4113,
  IfJson = 4114,
  CaseWhenInt = 4208,
  CaseWhenReal = 4209,
  CaseWhenDecimal = 4210,
  CaseWhenString = 4211,
  CaseWhenTime = 4212,
  CaseWhenDuration = 4213,
  CaseWhenJson = 4214,
  AesDecrypt = 4501,
  AesEncrypt = 4502,
  Compress = 4503,
  MD5 = 4504,
  Password = 4505,
  RandomBytes = 4506,
  SHA1 = 4507,
  SHA2 = 4508,
  Uncompress = 4509,
  UncompressedLength = 4510,
  Database = 4521,
  FoundRows = 4522,
  CurrentUser = 4523,
  User = 4524,
  ConnectionID = 4525,
  LastInsertID = 4526,
  LastInsertIDWithID = 4527,
  Version = 4528,
  TiDBVersion = 4529,
  RowCount = 4530,
  Sleep = 4551,
  Lock = 4552,
  ReleaseLock = 4553,
  DecimalAnyValue = 4554,
  DurationAnyValue = 4555,
  IntAnyValue = 4556,
  JSONAnyValue = 4557,
  RealAnyValue = 4558,
  StringAnyValue = 4559,
  TimeAnyValue = 4560,
  InetAton = 4561,
  InetNtoa = 4562,
  Inet6Aton = 4563,
  Inet6Ntoa = 4564,
  IsIPv4 = 4565,
  IsIPv4Compat = 4566,
  IsIPv4Mapped = 4567,
  IsIPv6 = 4568,
  UUID = 4569,
  LikeSig = 4310,
  RegexpBinarySig = 4311,
  RegexpSig = 4312,
  JsonExtractSig = 5001,
  JsonUnquoteSig = 5002,
  JsonTypeSig = 5003,
  JsonSetSig = 5004,
  JsonInsertSig = 5005,
  JsonReplaceSig = 5006,
  JsonRemoveSig = 5007,
  JsonMergeSig = 5008,
  JsonObjectSig = 5009,
  JsonArraySig = 5010,
  JsonValidJsonSig = 5011,
  JsonContainsSig = 5012,
  JsonArrayAppendSig = 5013,
  JsonArrayInsertSig = 5014,
  JsonMergePatchSig = 5015,
  JsonMergePreserveSig = 5016,
  JsonContainsPathSig = 5017,
  JsonPrettySig = 5018,
  JsonQuoteSig = 5019,
  JsonSearchSig = 5020,
  JsonStorageSizeSig = 5021,
  JsonDepthSig = 5022,
  JsonKeysSig = 5023,
  JsonLengthSig = 5024,
  JsonKeys2ArgsSig = 5025,
  JsonValidStringSig = 5026,
  JsonValidOthersSig = 5027,
  DateFormatSig = 6001,
  DateLiteral = 6002,
  DateDiff = 6003,
  NullTimeDiff = 6004,
  TimeStringTimeDiff = 6005,
  DurationStringTimeDiff = 6006,
  DurationDurationTimeDiff = 6007,
  StringTimeTimeDiff = 6008,
  StringDurationTimeDiff = 6009,
  StringStringTimeDiff = 6010,
  TimeTimeTimeDiff = 6011,
  Date = 6012,
  Hour = 6013,
  Minute = 6014,
  Second = 6015,
  MicroSecond = 6016,
  Month = 6017,
  MonthName = 6018,
  NowWithArg = 6019,
  NowWithoutArg = 6020,
  DayName = 6021,
  DayOfMonth = 6022,
  DayOfWeek = 6023,
  DayOfYear = 6024,
  WeekWithMode = 6025,
  WeekWithoutMode = 6026,
  WeekDay = 6027,
  WeekOfYear = 6028,
  Year = 6029,
  YearWeekWithMode = 6030,
  YearWeekWithoutMode = 6031,
  GetFormat = 6032,
  SysDateWithFsp = 6033,
  SysDateWithoutFsp = 6034,
  CurrentDate = 6035,
  CurrentTime0Arg = 6036,
  CurrentTime1Arg = 6037,
  Time = 6038,
  TimeLiteral = 6039,
  UTCDate = 6040,
  UTCTimestampWithArg = 6041,
  UTCTimestampWithoutArg = 6042,
  AddDatetimeAndDuration = 6043,
  AddDatetimeAndString = 6044,
  AddTimeDateTimeNull = 6045,
  AddStringAndDuration = 6046,
  AddStringAndString = 6047,
  AddTimeStringNull = 6048,
  AddDurationAndDuration = 6049,
  AddDurationAndString = 6050,
  AddTimeDurationNull = 6051,
  AddDateAndDuration = 6052,
  AddDateAndString = 6053,
  SubDatetimeAndDuration = 6054,
  SubDatetimeAndString = 6055,
  SubTimeDateTimeNull = 6056,
  SubStringAndDuration = 6057,
  SubStringAndString = 6058,
  SubTimeStringNull = 6059,
  SubDurationAndDuration = 6060,
  SubDurationAndString = 6061,
  SubTimeDurationNull = 6062,
  SubDateAndDuration = 6063,
  SubDateAndString = 6064,
  UnixTimestampCurrent = 6065,
  UnixTimestampInt = 6066,
  UnixTimestampDec = 6067,
  ConvertTz = 6068,
  MakeDate = 6069,
  MakeTime = 6070,
  PeriodAdd = 6071,
  PeriodDiff = 6072,
  Quarter = 6073,
  SecToTime = 6074,
  TimeToSec = 6075,
  TimestampAdd = 6076,
  ToDays = 6077,
  ToSeconds = 6078,
  UTCTimeWithArg = 6079,
  UTCTimeWithoutArg = 6080,
  Timestamp1Arg = 6081,
  Timestamp2Args = 6082,
  TimestampLiteral = 6083,
  LastDay = 6084,
  StrToDateDate = 6085,
  StrToDateDatetime = 6086,
  StrToDateDuration = 6087,
  FromUnixTime1Arg = 6088,
  FromUnixTime2Arg = 6089,
  ExtractDatetime = 6090,
  ExtractDuration = 6091,
  AddDateStringString = 6092,
  AddDateStringInt = 6093,
  AddDateStringDecimal = 6094,
  AddDateIntString = 6095,
  AddDateIntInt = 6096,
  AddDateDatetimeString = 6097,
  AddDateDatetimeInt = 6098,
  SubDateStringString = 6099,
  SubDateStringInt = 6100,
  SubDateStringDecimal = 6101,
  SubDateIntString = 6102,
  SubDateIntInt = 6103,
  SubDateDatetimeString = 6104,
  SubDateDatetimeInt = 6105,
  FromDays = 6106,
  TimeFormat = 6107,
  TimestampDiff = 6108,
  BitLength = 7001,
  Bin = 7002,
  ASCII = 7003,
  Char = 7004,
  CharLength = 7005,
  Concat = 7006,
  ConcatWS = 7007,
  Convert = 7008,
  Elt = 7009,
  ExportSet3Arg = 7010,
  ExportSet4Arg = 7011,
  ExportSet5Arg = 7012,
  FieldInt = 7013,
  FieldReal = 7014,
  FieldString = 7015,
  FindInSet = 7016,
  Format = 7017,
  FormatWithLocale = 7018,
  FromBase64 = 7019,
  HexIntArg = 7020,
  HexStrArg = 7021,
  Insert = 7022,
  InsertBinary = 7023,
  Instr = 7024,
  InstrBinary = 7025,
  LTrim = 7026,
  Left = 7027,
  LeftBinary = 7028,
  Length = 7029,
  Locate2Args = 7030,
  Locate3Args = 7031,
  LocateBinary2Args = 7032,
  LocateBinary3Args = 7033,
  Lower = 7034,
  Lpad = 7035,
  LpadBinary = 7036,
  MakeSet = 7037,
  OctInt = 7038,
  OctString = 7039,
  Ord = 7040,
  Quote = 7041,
  RTrim = 7042,
  Repeat = 7043,
  Replace = 7044,
  Reverse = 7045,
  ReverseBinary = 7046,
  Right = 7047,
  RightBinary = 7048,
  Rpad = 7049,
  RpadBinary = 7050,
  Space = 7051,
  Strcmp = 7052,
  Substring2Args = 7053,
  Substring3Args = 7054,
  SubstringBinary2Args = 7055,
  SubstringBinary3Args = 7056,
  SubstringIndex = 7057,
  ToBase64 = 7058,
  Trim1Arg = 7059,
  Trim2Args = 7060,
  Trim3Args = 7061,
  UnHex = 7062,
  Upper = 7063
};
bool ScalarFuncSig_IsValid(int value);
const ScalarFuncSig ScalarFuncSig_MIN = CastIntAsInt;
const ScalarFuncSig ScalarFuncSig_MAX = Upper;
const int ScalarFuncSig_ARRAYSIZE = ScalarFuncSig_MAX + 1;

const ::google::protobuf::EnumDescriptor* ScalarFuncSig_descriptor();
inline const ::std::string& ScalarFuncSig_Name(ScalarFuncSig value) {
  return ::google::protobuf::internal::NameOfEnum(
    ScalarFuncSig_descriptor(), value);
}
inline bool ScalarFuncSig_Parse(
    const ::std::string& name, ScalarFuncSig* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ScalarFuncSig>(
    ScalarFuncSig_descriptor(), name, value);
}
// ===================================================================

class FieldType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.FieldType) */ {
 public:
  FieldType();
  virtual ~FieldType();

  FieldType(const FieldType& from);

  inline FieldType& operator=(const FieldType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FieldType(FieldType&& from) noexcept
    : FieldType() {
    *this = ::std::move(from);
  }

  inline FieldType& operator=(FieldType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FieldType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FieldType* internal_default_instance() {
    return reinterpret_cast<const FieldType*>(
               &_FieldType_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(FieldType* other);
  friend void swap(FieldType& a, FieldType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FieldType* New() const PROTOBUF_FINAL { return New(NULL); }

  FieldType* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FieldType& from);
  void MergeFrom(const FieldType& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FieldType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string charset = 6;
  bool has_charset() const;
  void clear_charset();
  static const int kCharsetFieldNumber = 6;
  const ::std::string& charset() const;
  void set_charset(const ::std::string& value);
  #if LANG_CXX11
  void set_charset(::std::string&& value);
  #endif
  void set_charset(const char* value);
  void set_charset(const char* value, size_t size);
  ::std::string* mutable_charset();
  ::std::string* release_charset();
  void set_allocated_charset(::std::string* charset);

  // optional int32 tp = 1;
  bool has_tp() const;
  void clear_tp();
  static const int kTpFieldNumber = 1;
  ::google::protobuf::int32 tp() const;
  void set_tp(::google::protobuf::int32 value);

  // optional uint32 flag = 2;
  bool has_flag() const;
  void clear_flag();
  static const int kFlagFieldNumber = 2;
  ::google::protobuf::uint32 flag() const;
  void set_flag(::google::protobuf::uint32 value);

  // optional int32 flen = 3;
  bool has_flen() const;
  void clear_flen();
  static const int kFlenFieldNumber = 3;
  ::google::protobuf::int32 flen() const;
  void set_flen(::google::protobuf::int32 value);

  // optional int32 decimal = 4;
  bool has_decimal() const;
  void clear_decimal();
  static const int kDecimalFieldNumber = 4;
  ::google::protobuf::int32 decimal() const;
  void set_decimal(::google::protobuf::int32 value);

  // optional int32 collate = 5;
  bool has_collate() const;
  void clear_collate();
  static const int kCollateFieldNumber = 5;
  ::google::protobuf::int32 collate() const;
  void set_collate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tipb.FieldType)
 private:
  void set_has_tp();
  void clear_has_tp();
  void set_has_flag();
  void clear_has_flag();
  void set_has_flen();
  void clear_has_flen();
  void set_has_decimal();
  void clear_has_decimal();
  void set_has_collate();
  void clear_has_collate();
  void set_has_charset();
  void clear_has_charset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr charset_;
  ::google::protobuf::int32 tp_;
  ::google::protobuf::uint32 flag_;
  ::google::protobuf::int32 flen_;
  ::google::protobuf::int32 decimal_;
  ::google::protobuf::int32 collate_;
  friend struct ::protobuf_expression_2eproto::TableStruct;
  friend void ::protobuf_expression_2eproto::InitDefaultsFieldTypeImpl();
};
// -------------------------------------------------------------------

class Expr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.Expr) */ {
 public:
  Expr();
  virtual ~Expr();

  Expr(const Expr& from);

  inline Expr& operator=(const Expr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Expr(Expr&& from) noexcept
    : Expr() {
    *this = ::std::move(from);
  }

  inline Expr& operator=(Expr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Expr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Expr* internal_default_instance() {
    return reinterpret_cast<const Expr*>(
               &_Expr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Expr* other);
  friend void swap(Expr& a, Expr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Expr* New() const PROTOBUF_FINAL { return New(NULL); }

  Expr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Expr& from);
  void MergeFrom(const Expr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Expr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tipb.Expr children = 3;
  int children_size() const;
  void clear_children();
  static const int kChildrenFieldNumber = 3;
  const ::tipb::Expr& children(int index) const;
  ::tipb::Expr* mutable_children(int index);
  ::tipb::Expr* add_children();
  ::google::protobuf::RepeatedPtrField< ::tipb::Expr >*
      mutable_children();
  const ::google::protobuf::RepeatedPtrField< ::tipb::Expr >&
      children() const;

  // optional bytes val = 2;
  bool has_val() const;
  void clear_val();
  static const int kValFieldNumber = 2;
  const ::std::string& val() const;
  void set_val(const ::std::string& value);
  #if LANG_CXX11
  void set_val(::std::string&& value);
  #endif
  void set_val(const char* value);
  void set_val(const void* value, size_t size);
  ::std::string* mutable_val();
  ::std::string* release_val();
  void set_allocated_val(::std::string* val);

  // optional .tipb.FieldType field_type = 5;
  bool has_field_type() const;
  void clear_field_type();
  static const int kFieldTypeFieldNumber = 5;
  const ::tipb::FieldType& field_type() const;
  ::tipb::FieldType* release_field_type();
  ::tipb::FieldType* mutable_field_type();
  void set_allocated_field_type(::tipb::FieldType* field_type);

  // optional .tipb.ExprType tp = 1;
  bool has_tp() const;
  void clear_tp();
  static const int kTpFieldNumber = 1;
  ::tipb::ExprType tp() const;
  void set_tp(::tipb::ExprType value);

  // optional .tipb.ScalarFuncSig sig = 4;
  bool has_sig() const;
  void clear_sig();
  static const int kSigFieldNumber = 4;
  ::tipb::ScalarFuncSig sig() const;
  void set_sig(::tipb::ScalarFuncSig value);

  // @@protoc_insertion_point(class_scope:tipb.Expr)
 private:
  void set_has_tp();
  void clear_has_tp();
  void set_has_val();
  void clear_has_val();
  void set_has_sig();
  void clear_has_sig();
  void set_has_field_type();
  void clear_has_field_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tipb::Expr > children_;
  ::google::protobuf::internal::ArenaStringPtr val_;
  ::tipb::FieldType* field_type_;
  int tp_;
  int sig_;
  friend struct ::protobuf_expression_2eproto::TableStruct;
  friend void ::protobuf_expression_2eproto::InitDefaultsExprImpl();
};
// -------------------------------------------------------------------

class ByItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.ByItem) */ {
 public:
  ByItem();
  virtual ~ByItem();

  ByItem(const ByItem& from);

  inline ByItem& operator=(const ByItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ByItem(ByItem&& from) noexcept
    : ByItem() {
    *this = ::std::move(from);
  }

  inline ByItem& operator=(ByItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ByItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ByItem* internal_default_instance() {
    return reinterpret_cast<const ByItem*>(
               &_ByItem_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ByItem* other);
  friend void swap(ByItem& a, ByItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ByItem* New() const PROTOBUF_FINAL { return New(NULL); }

  ByItem* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ByItem& from);
  void MergeFrom(const ByItem& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ByItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tipb.Expr expr = 1;
  bool has_expr() const;
  void clear_expr();
  static const int kExprFieldNumber = 1;
  const ::tipb::Expr& expr() const;
  ::tipb::Expr* release_expr();
  ::tipb::Expr* mutable_expr();
  void set_allocated_expr(::tipb::Expr* expr);

  // optional bool desc = 2;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 2;
  bool desc() const;
  void set_desc(bool value);

  // @@protoc_insertion_point(class_scope:tipb.ByItem)
 private:
  void set_has_expr();
  void clear_has_expr();
  void set_has_desc();
  void clear_has_desc();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::tipb::Expr* expr_;
  bool desc_;
  friend struct ::protobuf_expression_2eproto::TableStruct;
  friend void ::protobuf_expression_2eproto::InitDefaultsByItemImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FieldType

// optional int32 tp = 1;
inline bool FieldType::has_tp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FieldType::set_has_tp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FieldType::clear_has_tp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FieldType::clear_tp() {
  tp_ = 0;
  clear_has_tp();
}
inline ::google::protobuf::int32 FieldType::tp() const {
  // @@protoc_insertion_point(field_get:tipb.FieldType.tp)
  return tp_;
}
inline void FieldType::set_tp(::google::protobuf::int32 value) {
  set_has_tp();
  tp_ = value;
  // @@protoc_insertion_point(field_set:tipb.FieldType.tp)
}

// optional uint32 flag = 2;
inline bool FieldType::has_flag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FieldType::set_has_flag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FieldType::clear_has_flag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FieldType::clear_flag() {
  flag_ = 0u;
  clear_has_flag();
}
inline ::google::protobuf::uint32 FieldType::flag() const {
  // @@protoc_insertion_point(field_get:tipb.FieldType.flag)
  return flag_;
}
inline void FieldType::set_flag(::google::protobuf::uint32 value) {
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:tipb.FieldType.flag)
}

// optional int32 flen = 3;
inline bool FieldType::has_flen() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FieldType::set_has_flen() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FieldType::clear_has_flen() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FieldType::clear_flen() {
  flen_ = 0;
  clear_has_flen();
}
inline ::google::protobuf::int32 FieldType::flen() const {
  // @@protoc_insertion_point(field_get:tipb.FieldType.flen)
  return flen_;
}
inline void FieldType::set_flen(::google::protobuf::int32 value) {
  set_has_flen();
  flen_ = value;
  // @@protoc_insertion_point(field_set:tipb.FieldType.flen)
}

// optional int32 decimal = 4;
inline bool FieldType::has_decimal() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FieldType::set_has_decimal() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FieldType::clear_has_decimal() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FieldType::clear_decimal() {
  decimal_ = 0;
  clear_has_decimal();
}
inline ::google::protobuf::int32 FieldType::decimal() const {
  // @@protoc_insertion_point(field_get:tipb.FieldType.decimal)
  return decimal_;
}
inline void FieldType::set_decimal(::google::protobuf::int32 value) {
  set_has_decimal();
  decimal_ = value;
  // @@protoc_insertion_point(field_set:tipb.FieldType.decimal)
}

// optional int32 collate = 5;
inline bool FieldType::has_collate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FieldType::set_has_collate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FieldType::clear_has_collate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FieldType::clear_collate() {
  collate_ = 0;
  clear_has_collate();
}
inline ::google::protobuf::int32 FieldType::collate() const {
  // @@protoc_insertion_point(field_get:tipb.FieldType.collate)
  return collate_;
}
inline void FieldType::set_collate(::google::protobuf::int32 value) {
  set_has_collate();
  collate_ = value;
  // @@protoc_insertion_point(field_set:tipb.FieldType.collate)
}

// optional string charset = 6;
inline bool FieldType::has_charset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FieldType::set_has_charset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FieldType::clear_has_charset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FieldType::clear_charset() {
  charset_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_charset();
}
inline const ::std::string& FieldType::charset() const {
  // @@protoc_insertion_point(field_get:tipb.FieldType.charset)
  return charset_.GetNoArena();
}
inline void FieldType::set_charset(const ::std::string& value) {
  set_has_charset();
  charset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tipb.FieldType.charset)
}
#if LANG_CXX11
inline void FieldType::set_charset(::std::string&& value) {
  set_has_charset();
  charset_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tipb.FieldType.charset)
}
#endif
inline void FieldType::set_charset(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_charset();
  charset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tipb.FieldType.charset)
}
inline void FieldType::set_charset(const char* value, size_t size) {
  set_has_charset();
  charset_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tipb.FieldType.charset)
}
inline ::std::string* FieldType::mutable_charset() {
  set_has_charset();
  // @@protoc_insertion_point(field_mutable:tipb.FieldType.charset)
  return charset_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FieldType::release_charset() {
  // @@protoc_insertion_point(field_release:tipb.FieldType.charset)
  clear_has_charset();
  return charset_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FieldType::set_allocated_charset(::std::string* charset) {
  if (charset != NULL) {
    set_has_charset();
  } else {
    clear_has_charset();
  }
  charset_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), charset);
  // @@protoc_insertion_point(field_set_allocated:tipb.FieldType.charset)
}

// -------------------------------------------------------------------

// Expr

// optional .tipb.ExprType tp = 1;
inline bool Expr::has_tp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Expr::set_has_tp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Expr::clear_has_tp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Expr::clear_tp() {
  tp_ = 0;
  clear_has_tp();
}
inline ::tipb::ExprType Expr::tp() const {
  // @@protoc_insertion_point(field_get:tipb.Expr.tp)
  return static_cast< ::tipb::ExprType >(tp_);
}
inline void Expr::set_tp(::tipb::ExprType value) {
  assert(::tipb::ExprType_IsValid(value));
  set_has_tp();
  tp_ = value;
  // @@protoc_insertion_point(field_set:tipb.Expr.tp)
}

// optional bytes val = 2;
inline bool Expr::has_val() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Expr::set_has_val() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Expr::clear_has_val() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Expr::clear_val() {
  val_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_val();
}
inline const ::std::string& Expr::val() const {
  // @@protoc_insertion_point(field_get:tipb.Expr.val)
  return val_.GetNoArena();
}
inline void Expr::set_val(const ::std::string& value) {
  set_has_val();
  val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tipb.Expr.val)
}
#if LANG_CXX11
inline void Expr::set_val(::std::string&& value) {
  set_has_val();
  val_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tipb.Expr.val)
}
#endif
inline void Expr::set_val(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_val();
  val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tipb.Expr.val)
}
inline void Expr::set_val(const void* value, size_t size) {
  set_has_val();
  val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tipb.Expr.val)
}
inline ::std::string* Expr::mutable_val() {
  set_has_val();
  // @@protoc_insertion_point(field_mutable:tipb.Expr.val)
  return val_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Expr::release_val() {
  // @@protoc_insertion_point(field_release:tipb.Expr.val)
  clear_has_val();
  return val_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Expr::set_allocated_val(::std::string* val) {
  if (val != NULL) {
    set_has_val();
  } else {
    clear_has_val();
  }
  val_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), val);
  // @@protoc_insertion_point(field_set_allocated:tipb.Expr.val)
}

// repeated .tipb.Expr children = 3;
inline int Expr::children_size() const {
  return children_.size();
}
inline void Expr::clear_children() {
  children_.Clear();
}
inline const ::tipb::Expr& Expr::children(int index) const {
  // @@protoc_insertion_point(field_get:tipb.Expr.children)
  return children_.Get(index);
}
inline ::tipb::Expr* Expr::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:tipb.Expr.children)
  return children_.Mutable(index);
}
inline ::tipb::Expr* Expr::add_children() {
  // @@protoc_insertion_point(field_add:tipb.Expr.children)
  return children_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tipb::Expr >*
Expr::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:tipb.Expr.children)
  return &children_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tipb::Expr >&
Expr::children() const {
  // @@protoc_insertion_point(field_list:tipb.Expr.children)
  return children_;
}

// optional .tipb.ScalarFuncSig sig = 4;
inline bool Expr::has_sig() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Expr::set_has_sig() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Expr::clear_has_sig() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Expr::clear_sig() {
  sig_ = 0;
  clear_has_sig();
}
inline ::tipb::ScalarFuncSig Expr::sig() const {
  // @@protoc_insertion_point(field_get:tipb.Expr.sig)
  return static_cast< ::tipb::ScalarFuncSig >(sig_);
}
inline void Expr::set_sig(::tipb::ScalarFuncSig value) {
  assert(::tipb::ScalarFuncSig_IsValid(value));
  set_has_sig();
  sig_ = value;
  // @@protoc_insertion_point(field_set:tipb.Expr.sig)
}

// optional .tipb.FieldType field_type = 5;
inline bool Expr::has_field_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Expr::set_has_field_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Expr::clear_has_field_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Expr::clear_field_type() {
  if (field_type_ != NULL) field_type_->Clear();
  clear_has_field_type();
}
inline const ::tipb::FieldType& Expr::field_type() const {
  const ::tipb::FieldType* p = field_type_;
  // @@protoc_insertion_point(field_get:tipb.Expr.field_type)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::FieldType*>(
      &::tipb::_FieldType_default_instance_);
}
inline ::tipb::FieldType* Expr::release_field_type() {
  // @@protoc_insertion_point(field_release:tipb.Expr.field_type)
  clear_has_field_type();
  ::tipb::FieldType* temp = field_type_;
  field_type_ = NULL;
  return temp;
}
inline ::tipb::FieldType* Expr::mutable_field_type() {
  set_has_field_type();
  if (field_type_ == NULL) {
    field_type_ = new ::tipb::FieldType;
  }
  // @@protoc_insertion_point(field_mutable:tipb.Expr.field_type)
  return field_type_;
}
inline void Expr::set_allocated_field_type(::tipb::FieldType* field_type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete field_type_;
  }
  if (field_type) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      field_type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, field_type, submessage_arena);
    }
    set_has_field_type();
  } else {
    clear_has_field_type();
  }
  field_type_ = field_type;
  // @@protoc_insertion_point(field_set_allocated:tipb.Expr.field_type)
}

// -------------------------------------------------------------------

// ByItem

// optional .tipb.Expr expr = 1;
inline bool ByItem::has_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ByItem::set_has_expr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ByItem::clear_has_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ByItem::clear_expr() {
  if (expr_ != NULL) expr_->Clear();
  clear_has_expr();
}
inline const ::tipb::Expr& ByItem::expr() const {
  const ::tipb::Expr* p = expr_;
  // @@protoc_insertion_point(field_get:tipb.ByItem.expr)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::Expr*>(
      &::tipb::_Expr_default_instance_);
}
inline ::tipb::Expr* ByItem::release_expr() {
  // @@protoc_insertion_point(field_release:tipb.ByItem.expr)
  clear_has_expr();
  ::tipb::Expr* temp = expr_;
  expr_ = NULL;
  return temp;
}
inline ::tipb::Expr* ByItem::mutable_expr() {
  set_has_expr();
  if (expr_ == NULL) {
    expr_ = new ::tipb::Expr;
  }
  // @@protoc_insertion_point(field_mutable:tipb.ByItem.expr)
  return expr_;
}
inline void ByItem::set_allocated_expr(::tipb::Expr* expr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete expr_;
  }
  if (expr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      expr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    set_has_expr();
  } else {
    clear_has_expr();
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:tipb.ByItem.expr)
}

// optional bool desc = 2;
inline bool ByItem::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ByItem::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ByItem::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ByItem::clear_desc() {
  desc_ = false;
  clear_has_desc();
}
inline bool ByItem::desc() const {
  // @@protoc_insertion_point(field_get:tipb.ByItem.desc)
  return desc_;
}
inline void ByItem::set_desc(bool value) {
  set_has_desc();
  desc_ = value;
  // @@protoc_insertion_point(field_set:tipb.ByItem.desc)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tipb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tipb::ExprType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tipb::ExprType>() {
  return ::tipb::ExprType_descriptor();
}
template <> struct is_proto_enum< ::tipb::ScalarFuncSig> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tipb::ScalarFuncSig>() {
  return ::tipb::ScalarFuncSig_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_expression_2eproto__INCLUDED
