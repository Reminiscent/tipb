// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: analyze.proto

#ifndef PROTOBUF_analyze_2eproto__INCLUDED
#define PROTOBUF_analyze_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "schema.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_analyze_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsAnalyzeReqImpl();
void InitDefaultsAnalyzeReq();
void InitDefaultsAnalyzeIndexReqImpl();
void InitDefaultsAnalyzeIndexReq();
void InitDefaultsAnalyzeColumnsReqImpl();
void InitDefaultsAnalyzeColumnsReq();
void InitDefaultsAnalyzeColumnsRespImpl();
void InitDefaultsAnalyzeColumnsResp();
void InitDefaultsAnalyzeIndexRespImpl();
void InitDefaultsAnalyzeIndexResp();
void InitDefaultsBucketImpl();
void InitDefaultsBucket();
void InitDefaultsHistogramImpl();
void InitDefaultsHistogram();
void InitDefaultsFMSketchImpl();
void InitDefaultsFMSketch();
void InitDefaultsSampleCollectorImpl();
void InitDefaultsSampleCollector();
void InitDefaultsCMSketchRowImpl();
void InitDefaultsCMSketchRow();
void InitDefaultsCMSketchTopNImpl();
void InitDefaultsCMSketchTopN();
void InitDefaultsCMSketchImpl();
void InitDefaultsCMSketch();
inline void InitDefaults() {
  InitDefaultsAnalyzeReq();
  InitDefaultsAnalyzeIndexReq();
  InitDefaultsAnalyzeColumnsReq();
  InitDefaultsAnalyzeColumnsResp();
  InitDefaultsAnalyzeIndexResp();
  InitDefaultsBucket();
  InitDefaultsHistogram();
  InitDefaultsFMSketch();
  InitDefaultsSampleCollector();
  InitDefaultsCMSketchRow();
  InitDefaultsCMSketchTopN();
  InitDefaultsCMSketch();
}
}  // namespace protobuf_analyze_2eproto
namespace tipb {
class AnalyzeColumnsReq;
class AnalyzeColumnsReqDefaultTypeInternal;
extern AnalyzeColumnsReqDefaultTypeInternal _AnalyzeColumnsReq_default_instance_;
class AnalyzeColumnsResp;
class AnalyzeColumnsRespDefaultTypeInternal;
extern AnalyzeColumnsRespDefaultTypeInternal _AnalyzeColumnsResp_default_instance_;
class AnalyzeIndexReq;
class AnalyzeIndexReqDefaultTypeInternal;
extern AnalyzeIndexReqDefaultTypeInternal _AnalyzeIndexReq_default_instance_;
class AnalyzeIndexResp;
class AnalyzeIndexRespDefaultTypeInternal;
extern AnalyzeIndexRespDefaultTypeInternal _AnalyzeIndexResp_default_instance_;
class AnalyzeReq;
class AnalyzeReqDefaultTypeInternal;
extern AnalyzeReqDefaultTypeInternal _AnalyzeReq_default_instance_;
class Bucket;
class BucketDefaultTypeInternal;
extern BucketDefaultTypeInternal _Bucket_default_instance_;
class CMSketch;
class CMSketchDefaultTypeInternal;
extern CMSketchDefaultTypeInternal _CMSketch_default_instance_;
class CMSketchRow;
class CMSketchRowDefaultTypeInternal;
extern CMSketchRowDefaultTypeInternal _CMSketchRow_default_instance_;
class CMSketchTopN;
class CMSketchTopNDefaultTypeInternal;
extern CMSketchTopNDefaultTypeInternal _CMSketchTopN_default_instance_;
class FMSketch;
class FMSketchDefaultTypeInternal;
extern FMSketchDefaultTypeInternal _FMSketch_default_instance_;
class Histogram;
class HistogramDefaultTypeInternal;
extern HistogramDefaultTypeInternal _Histogram_default_instance_;
class SampleCollector;
class SampleCollectorDefaultTypeInternal;
extern SampleCollectorDefaultTypeInternal _SampleCollector_default_instance_;
}  // namespace tipb
namespace tipb {

enum AnalyzeType {
  TypeIndex = 0,
  TypeColumn = 1
};
bool AnalyzeType_IsValid(int value);
const AnalyzeType AnalyzeType_MIN = TypeIndex;
const AnalyzeType AnalyzeType_MAX = TypeColumn;
const int AnalyzeType_ARRAYSIZE = AnalyzeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AnalyzeType_descriptor();
inline const ::std::string& AnalyzeType_Name(AnalyzeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AnalyzeType_descriptor(), value);
}
inline bool AnalyzeType_Parse(
    const ::std::string& name, AnalyzeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnalyzeType>(
    AnalyzeType_descriptor(), name, value);
}
// ===================================================================

class AnalyzeReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.AnalyzeReq) */ {
 public:
  AnalyzeReq();
  virtual ~AnalyzeReq();

  AnalyzeReq(const AnalyzeReq& from);

  inline AnalyzeReq& operator=(const AnalyzeReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalyzeReq(AnalyzeReq&& from) noexcept
    : AnalyzeReq() {
    *this = ::std::move(from);
  }

  inline AnalyzeReq& operator=(AnalyzeReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalyzeReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalyzeReq* internal_default_instance() {
    return reinterpret_cast<const AnalyzeReq*>(
               &_AnalyzeReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(AnalyzeReq* other);
  friend void swap(AnalyzeReq& a, AnalyzeReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalyzeReq* New() const PROTOBUF_FINAL { return New(NULL); }

  AnalyzeReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnalyzeReq& from);
  void MergeFrom(const AnalyzeReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnalyzeReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tipb.AnalyzeIndexReq idx_req = 5;
  bool has_idx_req() const;
  void clear_idx_req();
  static const int kIdxReqFieldNumber = 5;
  const ::tipb::AnalyzeIndexReq& idx_req() const;
  ::tipb::AnalyzeIndexReq* release_idx_req();
  ::tipb::AnalyzeIndexReq* mutable_idx_req();
  void set_allocated_idx_req(::tipb::AnalyzeIndexReq* idx_req);

  // optional .tipb.AnalyzeColumnsReq col_req = 6;
  bool has_col_req() const;
  void clear_col_req();
  static const int kColReqFieldNumber = 6;
  const ::tipb::AnalyzeColumnsReq& col_req() const;
  ::tipb::AnalyzeColumnsReq* release_col_req();
  ::tipb::AnalyzeColumnsReq* mutable_col_req();
  void set_allocated_col_req(::tipb::AnalyzeColumnsReq* col_req);

  // optional uint64 start_ts = 2;
  bool has_start_ts() const;
  void clear_start_ts();
  static const int kStartTsFieldNumber = 2;
  ::google::protobuf::uint64 start_ts() const;
  void set_start_ts(::google::protobuf::uint64 value);

  // optional uint64 flags = 3;
  bool has_flags() const;
  void clear_flags();
  static const int kFlagsFieldNumber = 3;
  ::google::protobuf::uint64 flags() const;
  void set_flags(::google::protobuf::uint64 value);

  // optional int64 time_zone_offset = 4;
  bool has_time_zone_offset() const;
  void clear_time_zone_offset();
  static const int kTimeZoneOffsetFieldNumber = 4;
  ::google::protobuf::int64 time_zone_offset() const;
  void set_time_zone_offset(::google::protobuf::int64 value);

  // optional .tipb.AnalyzeType tp = 1;
  bool has_tp() const;
  void clear_tp();
  static const int kTpFieldNumber = 1;
  ::tipb::AnalyzeType tp() const;
  void set_tp(::tipb::AnalyzeType value);

  // @@protoc_insertion_point(class_scope:tipb.AnalyzeReq)
 private:
  void set_has_tp();
  void clear_has_tp();
  void set_has_start_ts();
  void clear_has_start_ts();
  void set_has_flags();
  void clear_has_flags();
  void set_has_time_zone_offset();
  void clear_has_time_zone_offset();
  void set_has_idx_req();
  void clear_has_idx_req();
  void set_has_col_req();
  void clear_has_col_req();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::tipb::AnalyzeIndexReq* idx_req_;
  ::tipb::AnalyzeColumnsReq* col_req_;
  ::google::protobuf::uint64 start_ts_;
  ::google::protobuf::uint64 flags_;
  ::google::protobuf::int64 time_zone_offset_;
  int tp_;
  friend struct ::protobuf_analyze_2eproto::TableStruct;
  friend void ::protobuf_analyze_2eproto::InitDefaultsAnalyzeReqImpl();
};
// -------------------------------------------------------------------

class AnalyzeIndexReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.AnalyzeIndexReq) */ {
 public:
  AnalyzeIndexReq();
  virtual ~AnalyzeIndexReq();

  AnalyzeIndexReq(const AnalyzeIndexReq& from);

  inline AnalyzeIndexReq& operator=(const AnalyzeIndexReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalyzeIndexReq(AnalyzeIndexReq&& from) noexcept
    : AnalyzeIndexReq() {
    *this = ::std::move(from);
  }

  inline AnalyzeIndexReq& operator=(AnalyzeIndexReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalyzeIndexReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalyzeIndexReq* internal_default_instance() {
    return reinterpret_cast<const AnalyzeIndexReq*>(
               &_AnalyzeIndexReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AnalyzeIndexReq* other);
  friend void swap(AnalyzeIndexReq& a, AnalyzeIndexReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalyzeIndexReq* New() const PROTOBUF_FINAL { return New(NULL); }

  AnalyzeIndexReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnalyzeIndexReq& from);
  void MergeFrom(const AnalyzeIndexReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnalyzeIndexReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 bucket_size = 1;
  bool has_bucket_size() const;
  void clear_bucket_size();
  static const int kBucketSizeFieldNumber = 1;
  ::google::protobuf::int64 bucket_size() const;
  void set_bucket_size(::google::protobuf::int64 value);

  // optional int32 num_columns = 2;
  bool has_num_columns() const;
  void clear_num_columns();
  static const int kNumColumnsFieldNumber = 2;
  ::google::protobuf::int32 num_columns() const;
  void set_num_columns(::google::protobuf::int32 value);

  // optional int32 cmsketch_depth = 3;
  bool has_cmsketch_depth() const;
  void clear_cmsketch_depth();
  static const int kCmsketchDepthFieldNumber = 3;
  ::google::protobuf::int32 cmsketch_depth() const;
  void set_cmsketch_depth(::google::protobuf::int32 value);

  // optional int32 cmsketch_width = 4;
  bool has_cmsketch_width() const;
  void clear_cmsketch_width();
  static const int kCmsketchWidthFieldNumber = 4;
  ::google::protobuf::int32 cmsketch_width() const;
  void set_cmsketch_width(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tipb.AnalyzeIndexReq)
 private:
  void set_has_bucket_size();
  void clear_has_bucket_size();
  void set_has_num_columns();
  void clear_has_num_columns();
  void set_has_cmsketch_depth();
  void clear_has_cmsketch_depth();
  void set_has_cmsketch_width();
  void clear_has_cmsketch_width();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 bucket_size_;
  ::google::protobuf::int32 num_columns_;
  ::google::protobuf::int32 cmsketch_depth_;
  ::google::protobuf::int32 cmsketch_width_;
  friend struct ::protobuf_analyze_2eproto::TableStruct;
  friend void ::protobuf_analyze_2eproto::InitDefaultsAnalyzeIndexReqImpl();
};
// -------------------------------------------------------------------

class AnalyzeColumnsReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.AnalyzeColumnsReq) */ {
 public:
  AnalyzeColumnsReq();
  virtual ~AnalyzeColumnsReq();

  AnalyzeColumnsReq(const AnalyzeColumnsReq& from);

  inline AnalyzeColumnsReq& operator=(const AnalyzeColumnsReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalyzeColumnsReq(AnalyzeColumnsReq&& from) noexcept
    : AnalyzeColumnsReq() {
    *this = ::std::move(from);
  }

  inline AnalyzeColumnsReq& operator=(AnalyzeColumnsReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalyzeColumnsReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalyzeColumnsReq* internal_default_instance() {
    return reinterpret_cast<const AnalyzeColumnsReq*>(
               &_AnalyzeColumnsReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(AnalyzeColumnsReq* other);
  friend void swap(AnalyzeColumnsReq& a, AnalyzeColumnsReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalyzeColumnsReq* New() const PROTOBUF_FINAL { return New(NULL); }

  AnalyzeColumnsReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnalyzeColumnsReq& from);
  void MergeFrom(const AnalyzeColumnsReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnalyzeColumnsReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tipb.ColumnInfo columns_info = 4;
  int columns_info_size() const;
  void clear_columns_info();
  static const int kColumnsInfoFieldNumber = 4;
  const ::tipb::ColumnInfo& columns_info(int index) const;
  ::tipb::ColumnInfo* mutable_columns_info(int index);
  ::tipb::ColumnInfo* add_columns_info();
  ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo >*
      mutable_columns_info();
  const ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo >&
      columns_info() const;

  // optional int64 bucket_size = 1;
  bool has_bucket_size() const;
  void clear_bucket_size();
  static const int kBucketSizeFieldNumber = 1;
  ::google::protobuf::int64 bucket_size() const;
  void set_bucket_size(::google::protobuf::int64 value);

  // optional int64 sample_size = 2;
  bool has_sample_size() const;
  void clear_sample_size();
  static const int kSampleSizeFieldNumber = 2;
  ::google::protobuf::int64 sample_size() const;
  void set_sample_size(::google::protobuf::int64 value);

  // optional int64 sketch_size = 3;
  bool has_sketch_size() const;
  void clear_sketch_size();
  static const int kSketchSizeFieldNumber = 3;
  ::google::protobuf::int64 sketch_size() const;
  void set_sketch_size(::google::protobuf::int64 value);

  // optional int32 cmsketch_depth = 5;
  bool has_cmsketch_depth() const;
  void clear_cmsketch_depth();
  static const int kCmsketchDepthFieldNumber = 5;
  ::google::protobuf::int32 cmsketch_depth() const;
  void set_cmsketch_depth(::google::protobuf::int32 value);

  // optional int32 cmsketch_width = 6;
  bool has_cmsketch_width() const;
  void clear_cmsketch_width();
  static const int kCmsketchWidthFieldNumber = 6;
  ::google::protobuf::int32 cmsketch_width() const;
  void set_cmsketch_width(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tipb.AnalyzeColumnsReq)
 private:
  void set_has_bucket_size();
  void clear_has_bucket_size();
  void set_has_sample_size();
  void clear_has_sample_size();
  void set_has_sketch_size();
  void clear_has_sketch_size();
  void set_has_cmsketch_depth();
  void clear_has_cmsketch_depth();
  void set_has_cmsketch_width();
  void clear_has_cmsketch_width();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo > columns_info_;
  ::google::protobuf::int64 bucket_size_;
  ::google::protobuf::int64 sample_size_;
  ::google::protobuf::int64 sketch_size_;
  ::google::protobuf::int32 cmsketch_depth_;
  ::google::protobuf::int32 cmsketch_width_;
  friend struct ::protobuf_analyze_2eproto::TableStruct;
  friend void ::protobuf_analyze_2eproto::InitDefaultsAnalyzeColumnsReqImpl();
};
// -------------------------------------------------------------------

class AnalyzeColumnsResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.AnalyzeColumnsResp) */ {
 public:
  AnalyzeColumnsResp();
  virtual ~AnalyzeColumnsResp();

  AnalyzeColumnsResp(const AnalyzeColumnsResp& from);

  inline AnalyzeColumnsResp& operator=(const AnalyzeColumnsResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalyzeColumnsResp(AnalyzeColumnsResp&& from) noexcept
    : AnalyzeColumnsResp() {
    *this = ::std::move(from);
  }

  inline AnalyzeColumnsResp& operator=(AnalyzeColumnsResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalyzeColumnsResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalyzeColumnsResp* internal_default_instance() {
    return reinterpret_cast<const AnalyzeColumnsResp*>(
               &_AnalyzeColumnsResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(AnalyzeColumnsResp* other);
  friend void swap(AnalyzeColumnsResp& a, AnalyzeColumnsResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalyzeColumnsResp* New() const PROTOBUF_FINAL { return New(NULL); }

  AnalyzeColumnsResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnalyzeColumnsResp& from);
  void MergeFrom(const AnalyzeColumnsResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnalyzeColumnsResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tipb.SampleCollector collectors = 1;
  int collectors_size() const;
  void clear_collectors();
  static const int kCollectorsFieldNumber = 1;
  const ::tipb::SampleCollector& collectors(int index) const;
  ::tipb::SampleCollector* mutable_collectors(int index);
  ::tipb::SampleCollector* add_collectors();
  ::google::protobuf::RepeatedPtrField< ::tipb::SampleCollector >*
      mutable_collectors();
  const ::google::protobuf::RepeatedPtrField< ::tipb::SampleCollector >&
      collectors() const;

  // optional .tipb.Histogram pk_hist = 2;
  bool has_pk_hist() const;
  void clear_pk_hist();
  static const int kPkHistFieldNumber = 2;
  const ::tipb::Histogram& pk_hist() const;
  ::tipb::Histogram* release_pk_hist();
  ::tipb::Histogram* mutable_pk_hist();
  void set_allocated_pk_hist(::tipb::Histogram* pk_hist);

  // @@protoc_insertion_point(class_scope:tipb.AnalyzeColumnsResp)
 private:
  void set_has_pk_hist();
  void clear_has_pk_hist();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tipb::SampleCollector > collectors_;
  ::tipb::Histogram* pk_hist_;
  friend struct ::protobuf_analyze_2eproto::TableStruct;
  friend void ::protobuf_analyze_2eproto::InitDefaultsAnalyzeColumnsRespImpl();
};
// -------------------------------------------------------------------

class AnalyzeIndexResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.AnalyzeIndexResp) */ {
 public:
  AnalyzeIndexResp();
  virtual ~AnalyzeIndexResp();

  AnalyzeIndexResp(const AnalyzeIndexResp& from);

  inline AnalyzeIndexResp& operator=(const AnalyzeIndexResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AnalyzeIndexResp(AnalyzeIndexResp&& from) noexcept
    : AnalyzeIndexResp() {
    *this = ::std::move(from);
  }

  inline AnalyzeIndexResp& operator=(AnalyzeIndexResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AnalyzeIndexResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AnalyzeIndexResp* internal_default_instance() {
    return reinterpret_cast<const AnalyzeIndexResp*>(
               &_AnalyzeIndexResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(AnalyzeIndexResp* other);
  friend void swap(AnalyzeIndexResp& a, AnalyzeIndexResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AnalyzeIndexResp* New() const PROTOBUF_FINAL { return New(NULL); }

  AnalyzeIndexResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AnalyzeIndexResp& from);
  void MergeFrom(const AnalyzeIndexResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AnalyzeIndexResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .tipb.Histogram hist = 1;
  bool has_hist() const;
  void clear_hist();
  static const int kHistFieldNumber = 1;
  const ::tipb::Histogram& hist() const;
  ::tipb::Histogram* release_hist();
  ::tipb::Histogram* mutable_hist();
  void set_allocated_hist(::tipb::Histogram* hist);

  // optional .tipb.CMSketch cms = 2;
  bool has_cms() const;
  void clear_cms();
  static const int kCmsFieldNumber = 2;
  const ::tipb::CMSketch& cms() const;
  ::tipb::CMSketch* release_cms();
  ::tipb::CMSketch* mutable_cms();
  void set_allocated_cms(::tipb::CMSketch* cms);

  // @@protoc_insertion_point(class_scope:tipb.AnalyzeIndexResp)
 private:
  void set_has_hist();
  void clear_has_hist();
  void set_has_cms();
  void clear_has_cms();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::tipb::Histogram* hist_;
  ::tipb::CMSketch* cms_;
  friend struct ::protobuf_analyze_2eproto::TableStruct;
  friend void ::protobuf_analyze_2eproto::InitDefaultsAnalyzeIndexRespImpl();
};
// -------------------------------------------------------------------

class Bucket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.Bucket) */ {
 public:
  Bucket();
  virtual ~Bucket();

  Bucket(const Bucket& from);

  inline Bucket& operator=(const Bucket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Bucket(Bucket&& from) noexcept
    : Bucket() {
    *this = ::std::move(from);
  }

  inline Bucket& operator=(Bucket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Bucket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Bucket* internal_default_instance() {
    return reinterpret_cast<const Bucket*>(
               &_Bucket_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Bucket* other);
  friend void swap(Bucket& a, Bucket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Bucket* New() const PROTOBUF_FINAL { return New(NULL); }

  Bucket* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Bucket& from);
  void MergeFrom(const Bucket& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Bucket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes lower_bound = 2;
  bool has_lower_bound() const;
  void clear_lower_bound();
  static const int kLowerBoundFieldNumber = 2;
  const ::std::string& lower_bound() const;
  void set_lower_bound(const ::std::string& value);
  #if LANG_CXX11
  void set_lower_bound(::std::string&& value);
  #endif
  void set_lower_bound(const char* value);
  void set_lower_bound(const void* value, size_t size);
  ::std::string* mutable_lower_bound();
  ::std::string* release_lower_bound();
  void set_allocated_lower_bound(::std::string* lower_bound);

  // optional bytes upper_bound = 3;
  bool has_upper_bound() const;
  void clear_upper_bound();
  static const int kUpperBoundFieldNumber = 3;
  const ::std::string& upper_bound() const;
  void set_upper_bound(const ::std::string& value);
  #if LANG_CXX11
  void set_upper_bound(::std::string&& value);
  #endif
  void set_upper_bound(const char* value);
  void set_upper_bound(const void* value, size_t size);
  ::std::string* mutable_upper_bound();
  ::std::string* release_upper_bound();
  void set_allocated_upper_bound(::std::string* upper_bound);

  // optional int64 count = 1;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 1;
  ::google::protobuf::int64 count() const;
  void set_count(::google::protobuf::int64 value);

  // optional int64 repeats = 4;
  bool has_repeats() const;
  void clear_repeats();
  static const int kRepeatsFieldNumber = 4;
  ::google::protobuf::int64 repeats() const;
  void set_repeats(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tipb.Bucket)
 private:
  void set_has_count();
  void clear_has_count();
  void set_has_lower_bound();
  void clear_has_lower_bound();
  void set_has_upper_bound();
  void clear_has_upper_bound();
  void set_has_repeats();
  void clear_has_repeats();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr lower_bound_;
  ::google::protobuf::internal::ArenaStringPtr upper_bound_;
  ::google::protobuf::int64 count_;
  ::google::protobuf::int64 repeats_;
  friend struct ::protobuf_analyze_2eproto::TableStruct;
  friend void ::protobuf_analyze_2eproto::InitDefaultsBucketImpl();
};
// -------------------------------------------------------------------

class Histogram : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.Histogram) */ {
 public:
  Histogram();
  virtual ~Histogram();

  Histogram(const Histogram& from);

  inline Histogram& operator=(const Histogram& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Histogram(Histogram&& from) noexcept
    : Histogram() {
    *this = ::std::move(from);
  }

  inline Histogram& operator=(Histogram&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Histogram& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Histogram* internal_default_instance() {
    return reinterpret_cast<const Histogram*>(
               &_Histogram_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Histogram* other);
  friend void swap(Histogram& a, Histogram& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Histogram* New() const PROTOBUF_FINAL { return New(NULL); }

  Histogram* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Histogram& from);
  void MergeFrom(const Histogram& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Histogram* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tipb.Bucket buckets = 2;
  int buckets_size() const;
  void clear_buckets();
  static const int kBucketsFieldNumber = 2;
  const ::tipb::Bucket& buckets(int index) const;
  ::tipb::Bucket* mutable_buckets(int index);
  ::tipb::Bucket* add_buckets();
  ::google::protobuf::RepeatedPtrField< ::tipb::Bucket >*
      mutable_buckets();
  const ::google::protobuf::RepeatedPtrField< ::tipb::Bucket >&
      buckets() const;

  // optional int64 ndv = 1;
  bool has_ndv() const;
  void clear_ndv();
  static const int kNdvFieldNumber = 1;
  ::google::protobuf::int64 ndv() const;
  void set_ndv(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tipb.Histogram)
 private:
  void set_has_ndv();
  void clear_has_ndv();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tipb::Bucket > buckets_;
  ::google::protobuf::int64 ndv_;
  friend struct ::protobuf_analyze_2eproto::TableStruct;
  friend void ::protobuf_analyze_2eproto::InitDefaultsHistogramImpl();
};
// -------------------------------------------------------------------

class FMSketch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.FMSketch) */ {
 public:
  FMSketch();
  virtual ~FMSketch();

  FMSketch(const FMSketch& from);

  inline FMSketch& operator=(const FMSketch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FMSketch(FMSketch&& from) noexcept
    : FMSketch() {
    *this = ::std::move(from);
  }

  inline FMSketch& operator=(FMSketch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FMSketch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FMSketch* internal_default_instance() {
    return reinterpret_cast<const FMSketch*>(
               &_FMSketch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(FMSketch* other);
  friend void swap(FMSketch& a, FMSketch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FMSketch* New() const PROTOBUF_FINAL { return New(NULL); }

  FMSketch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FMSketch& from);
  void MergeFrom(const FMSketch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FMSketch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 hashset = 2;
  int hashset_size() const;
  void clear_hashset();
  static const int kHashsetFieldNumber = 2;
  ::google::protobuf::uint64 hashset(int index) const;
  void set_hashset(int index, ::google::protobuf::uint64 value);
  void add_hashset(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      hashset() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_hashset();

  // optional uint64 mask = 1;
  bool has_mask() const;
  void clear_mask();
  static const int kMaskFieldNumber = 1;
  ::google::protobuf::uint64 mask() const;
  void set_mask(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tipb.FMSketch)
 private:
  void set_has_mask();
  void clear_has_mask();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > hashset_;
  ::google::protobuf::uint64 mask_;
  friend struct ::protobuf_analyze_2eproto::TableStruct;
  friend void ::protobuf_analyze_2eproto::InitDefaultsFMSketchImpl();
};
// -------------------------------------------------------------------

class SampleCollector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.SampleCollector) */ {
 public:
  SampleCollector();
  virtual ~SampleCollector();

  SampleCollector(const SampleCollector& from);

  inline SampleCollector& operator=(const SampleCollector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SampleCollector(SampleCollector&& from) noexcept
    : SampleCollector() {
    *this = ::std::move(from);
  }

  inline SampleCollector& operator=(SampleCollector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SampleCollector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SampleCollector* internal_default_instance() {
    return reinterpret_cast<const SampleCollector*>(
               &_SampleCollector_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(SampleCollector* other);
  friend void swap(SampleCollector& a, SampleCollector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SampleCollector* New() const PROTOBUF_FINAL { return New(NULL); }

  SampleCollector* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SampleCollector& from);
  void MergeFrom(const SampleCollector& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SampleCollector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes samples = 1;
  int samples_size() const;
  void clear_samples();
  static const int kSamplesFieldNumber = 1;
  const ::std::string& samples(int index) const;
  ::std::string* mutable_samples(int index);
  void set_samples(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_samples(int index, ::std::string&& value);
  #endif
  void set_samples(int index, const char* value);
  void set_samples(int index, const void* value, size_t size);
  ::std::string* add_samples();
  void add_samples(const ::std::string& value);
  #if LANG_CXX11
  void add_samples(::std::string&& value);
  #endif
  void add_samples(const char* value);
  void add_samples(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& samples() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_samples();

  // optional .tipb.FMSketch fm_sketch = 4;
  bool has_fm_sketch() const;
  void clear_fm_sketch();
  static const int kFmSketchFieldNumber = 4;
  const ::tipb::FMSketch& fm_sketch() const;
  ::tipb::FMSketch* release_fm_sketch();
  ::tipb::FMSketch* mutable_fm_sketch();
  void set_allocated_fm_sketch(::tipb::FMSketch* fm_sketch);

  // optional .tipb.CMSketch cm_sketch = 5;
  bool has_cm_sketch() const;
  void clear_cm_sketch();
  static const int kCmSketchFieldNumber = 5;
  const ::tipb::CMSketch& cm_sketch() const;
  ::tipb::CMSketch* release_cm_sketch();
  ::tipb::CMSketch* mutable_cm_sketch();
  void set_allocated_cm_sketch(::tipb::CMSketch* cm_sketch);

  // optional int64 null_count = 2;
  bool has_null_count() const;
  void clear_null_count();
  static const int kNullCountFieldNumber = 2;
  ::google::protobuf::int64 null_count() const;
  void set_null_count(::google::protobuf::int64 value);

  // optional int64 count = 3;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::int64 count() const;
  void set_count(::google::protobuf::int64 value);

  // optional int64 total_size = 6;
  bool has_total_size() const;
  void clear_total_size();
  static const int kTotalSizeFieldNumber = 6;
  ::google::protobuf::int64 total_size() const;
  void set_total_size(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tipb.SampleCollector)
 private:
  void set_has_null_count();
  void clear_has_null_count();
  void set_has_count();
  void clear_has_count();
  void set_has_fm_sketch();
  void clear_has_fm_sketch();
  void set_has_cm_sketch();
  void clear_has_cm_sketch();
  void set_has_total_size();
  void clear_has_total_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> samples_;
  ::tipb::FMSketch* fm_sketch_;
  ::tipb::CMSketch* cm_sketch_;
  ::google::protobuf::int64 null_count_;
  ::google::protobuf::int64 count_;
  ::google::protobuf::int64 total_size_;
  friend struct ::protobuf_analyze_2eproto::TableStruct;
  friend void ::protobuf_analyze_2eproto::InitDefaultsSampleCollectorImpl();
};
// -------------------------------------------------------------------

class CMSketchRow : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.CMSketchRow) */ {
 public:
  CMSketchRow();
  virtual ~CMSketchRow();

  CMSketchRow(const CMSketchRow& from);

  inline CMSketchRow& operator=(const CMSketchRow& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMSketchRow(CMSketchRow&& from) noexcept
    : CMSketchRow() {
    *this = ::std::move(from);
  }

  inline CMSketchRow& operator=(CMSketchRow&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMSketchRow& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMSketchRow* internal_default_instance() {
    return reinterpret_cast<const CMSketchRow*>(
               &_CMSketchRow_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(CMSketchRow* other);
  friend void swap(CMSketchRow& a, CMSketchRow& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMSketchRow* New() const PROTOBUF_FINAL { return New(NULL); }

  CMSketchRow* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMSketchRow& from);
  void MergeFrom(const CMSketchRow& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMSketchRow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 counters = 1;
  int counters_size() const;
  void clear_counters();
  static const int kCountersFieldNumber = 1;
  ::google::protobuf::uint32 counters(int index) const;
  void set_counters(int index, ::google::protobuf::uint32 value);
  void add_counters(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      counters() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_counters();

  // @@protoc_insertion_point(class_scope:tipb.CMSketchRow)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > counters_;
  friend struct ::protobuf_analyze_2eproto::TableStruct;
  friend void ::protobuf_analyze_2eproto::InitDefaultsCMSketchRowImpl();
};
// -------------------------------------------------------------------

class CMSketchTopN : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.CMSketchTopN) */ {
 public:
  CMSketchTopN();
  virtual ~CMSketchTopN();

  CMSketchTopN(const CMSketchTopN& from);

  inline CMSketchTopN& operator=(const CMSketchTopN& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMSketchTopN(CMSketchTopN&& from) noexcept
    : CMSketchTopN() {
    *this = ::std::move(from);
  }

  inline CMSketchTopN& operator=(CMSketchTopN&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMSketchTopN& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMSketchTopN* internal_default_instance() {
    return reinterpret_cast<const CMSketchTopN*>(
               &_CMSketchTopN_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(CMSketchTopN* other);
  friend void swap(CMSketchTopN& a, CMSketchTopN& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMSketchTopN* New() const PROTOBUF_FINAL { return New(NULL); }

  CMSketchTopN* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMSketchTopN& from);
  void MergeFrom(const CMSketchTopN& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMSketchTopN* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional uint64 count = 2;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 2;
  ::google::protobuf::uint64 count() const;
  void set_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tipb.CMSketchTopN)
 private:
  void set_has_data();
  void clear_has_data();
  void set_has_count();
  void clear_has_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::uint64 count_;
  friend struct ::protobuf_analyze_2eproto::TableStruct;
  friend void ::protobuf_analyze_2eproto::InitDefaultsCMSketchTopNImpl();
};
// -------------------------------------------------------------------

class CMSketch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tipb.CMSketch) */ {
 public:
  CMSketch();
  virtual ~CMSketch();

  CMSketch(const CMSketch& from);

  inline CMSketch& operator=(const CMSketch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CMSketch(CMSketch&& from) noexcept
    : CMSketch() {
    *this = ::std::move(from);
  }

  inline CMSketch& operator=(CMSketch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CMSketch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CMSketch* internal_default_instance() {
    return reinterpret_cast<const CMSketch*>(
               &_CMSketch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(CMSketch* other);
  friend void swap(CMSketch& a, CMSketch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CMSketch* New() const PROTOBUF_FINAL { return New(NULL); }

  CMSketch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CMSketch& from);
  void MergeFrom(const CMSketch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CMSketch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tipb.CMSketchRow rows = 1;
  int rows_size() const;
  void clear_rows();
  static const int kRowsFieldNumber = 1;
  const ::tipb::CMSketchRow& rows(int index) const;
  ::tipb::CMSketchRow* mutable_rows(int index);
  ::tipb::CMSketchRow* add_rows();
  ::google::protobuf::RepeatedPtrField< ::tipb::CMSketchRow >*
      mutable_rows();
  const ::google::protobuf::RepeatedPtrField< ::tipb::CMSketchRow >&
      rows() const;

  // repeated .tipb.CMSketchTopN top_n = 2;
  int top_n_size() const;
  void clear_top_n();
  static const int kTopNFieldNumber = 2;
  const ::tipb::CMSketchTopN& top_n(int index) const;
  ::tipb::CMSketchTopN* mutable_top_n(int index);
  ::tipb::CMSketchTopN* add_top_n();
  ::google::protobuf::RepeatedPtrField< ::tipb::CMSketchTopN >*
      mutable_top_n();
  const ::google::protobuf::RepeatedPtrField< ::tipb::CMSketchTopN >&
      top_n() const;

  // optional uint64 default_value = 3;
  bool has_default_value() const;
  void clear_default_value();
  static const int kDefaultValueFieldNumber = 3;
  ::google::protobuf::uint64 default_value() const;
  void set_default_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tipb.CMSketch)
 private:
  void set_has_default_value();
  void clear_has_default_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tipb::CMSketchRow > rows_;
  ::google::protobuf::RepeatedPtrField< ::tipb::CMSketchTopN > top_n_;
  ::google::protobuf::uint64 default_value_;
  friend struct ::protobuf_analyze_2eproto::TableStruct;
  friend void ::protobuf_analyze_2eproto::InitDefaultsCMSketchImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AnalyzeReq

// optional .tipb.AnalyzeType tp = 1;
inline bool AnalyzeReq::has_tp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AnalyzeReq::set_has_tp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AnalyzeReq::clear_has_tp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AnalyzeReq::clear_tp() {
  tp_ = 0;
  clear_has_tp();
}
inline ::tipb::AnalyzeType AnalyzeReq::tp() const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeReq.tp)
  return static_cast< ::tipb::AnalyzeType >(tp_);
}
inline void AnalyzeReq::set_tp(::tipb::AnalyzeType value) {
  assert(::tipb::AnalyzeType_IsValid(value));
  set_has_tp();
  tp_ = value;
  // @@protoc_insertion_point(field_set:tipb.AnalyzeReq.tp)
}

// optional uint64 start_ts = 2;
inline bool AnalyzeReq::has_start_ts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnalyzeReq::set_has_start_ts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnalyzeReq::clear_has_start_ts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnalyzeReq::clear_start_ts() {
  start_ts_ = GOOGLE_ULONGLONG(0);
  clear_has_start_ts();
}
inline ::google::protobuf::uint64 AnalyzeReq::start_ts() const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeReq.start_ts)
  return start_ts_;
}
inline void AnalyzeReq::set_start_ts(::google::protobuf::uint64 value) {
  set_has_start_ts();
  start_ts_ = value;
  // @@protoc_insertion_point(field_set:tipb.AnalyzeReq.start_ts)
}

// optional uint64 flags = 3;
inline bool AnalyzeReq::has_flags() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnalyzeReq::set_has_flags() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnalyzeReq::clear_has_flags() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnalyzeReq::clear_flags() {
  flags_ = GOOGLE_ULONGLONG(0);
  clear_has_flags();
}
inline ::google::protobuf::uint64 AnalyzeReq::flags() const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeReq.flags)
  return flags_;
}
inline void AnalyzeReq::set_flags(::google::protobuf::uint64 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:tipb.AnalyzeReq.flags)
}

// optional int64 time_zone_offset = 4;
inline bool AnalyzeReq::has_time_zone_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnalyzeReq::set_has_time_zone_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnalyzeReq::clear_has_time_zone_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnalyzeReq::clear_time_zone_offset() {
  time_zone_offset_ = GOOGLE_LONGLONG(0);
  clear_has_time_zone_offset();
}
inline ::google::protobuf::int64 AnalyzeReq::time_zone_offset() const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeReq.time_zone_offset)
  return time_zone_offset_;
}
inline void AnalyzeReq::set_time_zone_offset(::google::protobuf::int64 value) {
  set_has_time_zone_offset();
  time_zone_offset_ = value;
  // @@protoc_insertion_point(field_set:tipb.AnalyzeReq.time_zone_offset)
}

// optional .tipb.AnalyzeIndexReq idx_req = 5;
inline bool AnalyzeReq::has_idx_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnalyzeReq::set_has_idx_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnalyzeReq::clear_has_idx_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnalyzeReq::clear_idx_req() {
  if (idx_req_ != NULL) idx_req_->Clear();
  clear_has_idx_req();
}
inline const ::tipb::AnalyzeIndexReq& AnalyzeReq::idx_req() const {
  const ::tipb::AnalyzeIndexReq* p = idx_req_;
  // @@protoc_insertion_point(field_get:tipb.AnalyzeReq.idx_req)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::AnalyzeIndexReq*>(
      &::tipb::_AnalyzeIndexReq_default_instance_);
}
inline ::tipb::AnalyzeIndexReq* AnalyzeReq::release_idx_req() {
  // @@protoc_insertion_point(field_release:tipb.AnalyzeReq.idx_req)
  clear_has_idx_req();
  ::tipb::AnalyzeIndexReq* temp = idx_req_;
  idx_req_ = NULL;
  return temp;
}
inline ::tipb::AnalyzeIndexReq* AnalyzeReq::mutable_idx_req() {
  set_has_idx_req();
  if (idx_req_ == NULL) {
    idx_req_ = new ::tipb::AnalyzeIndexReq;
  }
  // @@protoc_insertion_point(field_mutable:tipb.AnalyzeReq.idx_req)
  return idx_req_;
}
inline void AnalyzeReq::set_allocated_idx_req(::tipb::AnalyzeIndexReq* idx_req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete idx_req_;
  }
  if (idx_req) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      idx_req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, idx_req, submessage_arena);
    }
    set_has_idx_req();
  } else {
    clear_has_idx_req();
  }
  idx_req_ = idx_req;
  // @@protoc_insertion_point(field_set_allocated:tipb.AnalyzeReq.idx_req)
}

// optional .tipb.AnalyzeColumnsReq col_req = 6;
inline bool AnalyzeReq::has_col_req() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnalyzeReq::set_has_col_req() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnalyzeReq::clear_has_col_req() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnalyzeReq::clear_col_req() {
  if (col_req_ != NULL) col_req_->Clear();
  clear_has_col_req();
}
inline const ::tipb::AnalyzeColumnsReq& AnalyzeReq::col_req() const {
  const ::tipb::AnalyzeColumnsReq* p = col_req_;
  // @@protoc_insertion_point(field_get:tipb.AnalyzeReq.col_req)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::AnalyzeColumnsReq*>(
      &::tipb::_AnalyzeColumnsReq_default_instance_);
}
inline ::tipb::AnalyzeColumnsReq* AnalyzeReq::release_col_req() {
  // @@protoc_insertion_point(field_release:tipb.AnalyzeReq.col_req)
  clear_has_col_req();
  ::tipb::AnalyzeColumnsReq* temp = col_req_;
  col_req_ = NULL;
  return temp;
}
inline ::tipb::AnalyzeColumnsReq* AnalyzeReq::mutable_col_req() {
  set_has_col_req();
  if (col_req_ == NULL) {
    col_req_ = new ::tipb::AnalyzeColumnsReq;
  }
  // @@protoc_insertion_point(field_mutable:tipb.AnalyzeReq.col_req)
  return col_req_;
}
inline void AnalyzeReq::set_allocated_col_req(::tipb::AnalyzeColumnsReq* col_req) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete col_req_;
  }
  if (col_req) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      col_req = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, col_req, submessage_arena);
    }
    set_has_col_req();
  } else {
    clear_has_col_req();
  }
  col_req_ = col_req;
  // @@protoc_insertion_point(field_set_allocated:tipb.AnalyzeReq.col_req)
}

// -------------------------------------------------------------------

// AnalyzeIndexReq

// optional int64 bucket_size = 1;
inline bool AnalyzeIndexReq::has_bucket_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnalyzeIndexReq::set_has_bucket_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnalyzeIndexReq::clear_has_bucket_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnalyzeIndexReq::clear_bucket_size() {
  bucket_size_ = GOOGLE_LONGLONG(0);
  clear_has_bucket_size();
}
inline ::google::protobuf::int64 AnalyzeIndexReq::bucket_size() const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeIndexReq.bucket_size)
  return bucket_size_;
}
inline void AnalyzeIndexReq::set_bucket_size(::google::protobuf::int64 value) {
  set_has_bucket_size();
  bucket_size_ = value;
  // @@protoc_insertion_point(field_set:tipb.AnalyzeIndexReq.bucket_size)
}

// optional int32 num_columns = 2;
inline bool AnalyzeIndexReq::has_num_columns() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnalyzeIndexReq::set_has_num_columns() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnalyzeIndexReq::clear_has_num_columns() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnalyzeIndexReq::clear_num_columns() {
  num_columns_ = 0;
  clear_has_num_columns();
}
inline ::google::protobuf::int32 AnalyzeIndexReq::num_columns() const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeIndexReq.num_columns)
  return num_columns_;
}
inline void AnalyzeIndexReq::set_num_columns(::google::protobuf::int32 value) {
  set_has_num_columns();
  num_columns_ = value;
  // @@protoc_insertion_point(field_set:tipb.AnalyzeIndexReq.num_columns)
}

// optional int32 cmsketch_depth = 3;
inline bool AnalyzeIndexReq::has_cmsketch_depth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnalyzeIndexReq::set_has_cmsketch_depth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnalyzeIndexReq::clear_has_cmsketch_depth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnalyzeIndexReq::clear_cmsketch_depth() {
  cmsketch_depth_ = 0;
  clear_has_cmsketch_depth();
}
inline ::google::protobuf::int32 AnalyzeIndexReq::cmsketch_depth() const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeIndexReq.cmsketch_depth)
  return cmsketch_depth_;
}
inline void AnalyzeIndexReq::set_cmsketch_depth(::google::protobuf::int32 value) {
  set_has_cmsketch_depth();
  cmsketch_depth_ = value;
  // @@protoc_insertion_point(field_set:tipb.AnalyzeIndexReq.cmsketch_depth)
}

// optional int32 cmsketch_width = 4;
inline bool AnalyzeIndexReq::has_cmsketch_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnalyzeIndexReq::set_has_cmsketch_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnalyzeIndexReq::clear_has_cmsketch_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnalyzeIndexReq::clear_cmsketch_width() {
  cmsketch_width_ = 0;
  clear_has_cmsketch_width();
}
inline ::google::protobuf::int32 AnalyzeIndexReq::cmsketch_width() const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeIndexReq.cmsketch_width)
  return cmsketch_width_;
}
inline void AnalyzeIndexReq::set_cmsketch_width(::google::protobuf::int32 value) {
  set_has_cmsketch_width();
  cmsketch_width_ = value;
  // @@protoc_insertion_point(field_set:tipb.AnalyzeIndexReq.cmsketch_width)
}

// -------------------------------------------------------------------

// AnalyzeColumnsReq

// optional int64 bucket_size = 1;
inline bool AnalyzeColumnsReq::has_bucket_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnalyzeColumnsReq::set_has_bucket_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnalyzeColumnsReq::clear_has_bucket_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnalyzeColumnsReq::clear_bucket_size() {
  bucket_size_ = GOOGLE_LONGLONG(0);
  clear_has_bucket_size();
}
inline ::google::protobuf::int64 AnalyzeColumnsReq::bucket_size() const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeColumnsReq.bucket_size)
  return bucket_size_;
}
inline void AnalyzeColumnsReq::set_bucket_size(::google::protobuf::int64 value) {
  set_has_bucket_size();
  bucket_size_ = value;
  // @@protoc_insertion_point(field_set:tipb.AnalyzeColumnsReq.bucket_size)
}

// optional int64 sample_size = 2;
inline bool AnalyzeColumnsReq::has_sample_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnalyzeColumnsReq::set_has_sample_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnalyzeColumnsReq::clear_has_sample_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnalyzeColumnsReq::clear_sample_size() {
  sample_size_ = GOOGLE_LONGLONG(0);
  clear_has_sample_size();
}
inline ::google::protobuf::int64 AnalyzeColumnsReq::sample_size() const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeColumnsReq.sample_size)
  return sample_size_;
}
inline void AnalyzeColumnsReq::set_sample_size(::google::protobuf::int64 value) {
  set_has_sample_size();
  sample_size_ = value;
  // @@protoc_insertion_point(field_set:tipb.AnalyzeColumnsReq.sample_size)
}

// optional int64 sketch_size = 3;
inline bool AnalyzeColumnsReq::has_sketch_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AnalyzeColumnsReq::set_has_sketch_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AnalyzeColumnsReq::clear_has_sketch_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AnalyzeColumnsReq::clear_sketch_size() {
  sketch_size_ = GOOGLE_LONGLONG(0);
  clear_has_sketch_size();
}
inline ::google::protobuf::int64 AnalyzeColumnsReq::sketch_size() const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeColumnsReq.sketch_size)
  return sketch_size_;
}
inline void AnalyzeColumnsReq::set_sketch_size(::google::protobuf::int64 value) {
  set_has_sketch_size();
  sketch_size_ = value;
  // @@protoc_insertion_point(field_set:tipb.AnalyzeColumnsReq.sketch_size)
}

// repeated .tipb.ColumnInfo columns_info = 4;
inline int AnalyzeColumnsReq::columns_info_size() const {
  return columns_info_.size();
}
inline const ::tipb::ColumnInfo& AnalyzeColumnsReq::columns_info(int index) const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeColumnsReq.columns_info)
  return columns_info_.Get(index);
}
inline ::tipb::ColumnInfo* AnalyzeColumnsReq::mutable_columns_info(int index) {
  // @@protoc_insertion_point(field_mutable:tipb.AnalyzeColumnsReq.columns_info)
  return columns_info_.Mutable(index);
}
inline ::tipb::ColumnInfo* AnalyzeColumnsReq::add_columns_info() {
  // @@protoc_insertion_point(field_add:tipb.AnalyzeColumnsReq.columns_info)
  return columns_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo >*
AnalyzeColumnsReq::mutable_columns_info() {
  // @@protoc_insertion_point(field_mutable_list:tipb.AnalyzeColumnsReq.columns_info)
  return &columns_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tipb::ColumnInfo >&
AnalyzeColumnsReq::columns_info() const {
  // @@protoc_insertion_point(field_list:tipb.AnalyzeColumnsReq.columns_info)
  return columns_info_;
}

// optional int32 cmsketch_depth = 5;
inline bool AnalyzeColumnsReq::has_cmsketch_depth() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AnalyzeColumnsReq::set_has_cmsketch_depth() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AnalyzeColumnsReq::clear_has_cmsketch_depth() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AnalyzeColumnsReq::clear_cmsketch_depth() {
  cmsketch_depth_ = 0;
  clear_has_cmsketch_depth();
}
inline ::google::protobuf::int32 AnalyzeColumnsReq::cmsketch_depth() const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeColumnsReq.cmsketch_depth)
  return cmsketch_depth_;
}
inline void AnalyzeColumnsReq::set_cmsketch_depth(::google::protobuf::int32 value) {
  set_has_cmsketch_depth();
  cmsketch_depth_ = value;
  // @@protoc_insertion_point(field_set:tipb.AnalyzeColumnsReq.cmsketch_depth)
}

// optional int32 cmsketch_width = 6;
inline bool AnalyzeColumnsReq::has_cmsketch_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AnalyzeColumnsReq::set_has_cmsketch_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AnalyzeColumnsReq::clear_has_cmsketch_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AnalyzeColumnsReq::clear_cmsketch_width() {
  cmsketch_width_ = 0;
  clear_has_cmsketch_width();
}
inline ::google::protobuf::int32 AnalyzeColumnsReq::cmsketch_width() const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeColumnsReq.cmsketch_width)
  return cmsketch_width_;
}
inline void AnalyzeColumnsReq::set_cmsketch_width(::google::protobuf::int32 value) {
  set_has_cmsketch_width();
  cmsketch_width_ = value;
  // @@protoc_insertion_point(field_set:tipb.AnalyzeColumnsReq.cmsketch_width)
}

// -------------------------------------------------------------------

// AnalyzeColumnsResp

// repeated .tipb.SampleCollector collectors = 1;
inline int AnalyzeColumnsResp::collectors_size() const {
  return collectors_.size();
}
inline void AnalyzeColumnsResp::clear_collectors() {
  collectors_.Clear();
}
inline const ::tipb::SampleCollector& AnalyzeColumnsResp::collectors(int index) const {
  // @@protoc_insertion_point(field_get:tipb.AnalyzeColumnsResp.collectors)
  return collectors_.Get(index);
}
inline ::tipb::SampleCollector* AnalyzeColumnsResp::mutable_collectors(int index) {
  // @@protoc_insertion_point(field_mutable:tipb.AnalyzeColumnsResp.collectors)
  return collectors_.Mutable(index);
}
inline ::tipb::SampleCollector* AnalyzeColumnsResp::add_collectors() {
  // @@protoc_insertion_point(field_add:tipb.AnalyzeColumnsResp.collectors)
  return collectors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tipb::SampleCollector >*
AnalyzeColumnsResp::mutable_collectors() {
  // @@protoc_insertion_point(field_mutable_list:tipb.AnalyzeColumnsResp.collectors)
  return &collectors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tipb::SampleCollector >&
AnalyzeColumnsResp::collectors() const {
  // @@protoc_insertion_point(field_list:tipb.AnalyzeColumnsResp.collectors)
  return collectors_;
}

// optional .tipb.Histogram pk_hist = 2;
inline bool AnalyzeColumnsResp::has_pk_hist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnalyzeColumnsResp::set_has_pk_hist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnalyzeColumnsResp::clear_has_pk_hist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnalyzeColumnsResp::clear_pk_hist() {
  if (pk_hist_ != NULL) pk_hist_->Clear();
  clear_has_pk_hist();
}
inline const ::tipb::Histogram& AnalyzeColumnsResp::pk_hist() const {
  const ::tipb::Histogram* p = pk_hist_;
  // @@protoc_insertion_point(field_get:tipb.AnalyzeColumnsResp.pk_hist)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::Histogram*>(
      &::tipb::_Histogram_default_instance_);
}
inline ::tipb::Histogram* AnalyzeColumnsResp::release_pk_hist() {
  // @@protoc_insertion_point(field_release:tipb.AnalyzeColumnsResp.pk_hist)
  clear_has_pk_hist();
  ::tipb::Histogram* temp = pk_hist_;
  pk_hist_ = NULL;
  return temp;
}
inline ::tipb::Histogram* AnalyzeColumnsResp::mutable_pk_hist() {
  set_has_pk_hist();
  if (pk_hist_ == NULL) {
    pk_hist_ = new ::tipb::Histogram;
  }
  // @@protoc_insertion_point(field_mutable:tipb.AnalyzeColumnsResp.pk_hist)
  return pk_hist_;
}
inline void AnalyzeColumnsResp::set_allocated_pk_hist(::tipb::Histogram* pk_hist) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pk_hist_;
  }
  if (pk_hist) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pk_hist = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pk_hist, submessage_arena);
    }
    set_has_pk_hist();
  } else {
    clear_has_pk_hist();
  }
  pk_hist_ = pk_hist;
  // @@protoc_insertion_point(field_set_allocated:tipb.AnalyzeColumnsResp.pk_hist)
}

// -------------------------------------------------------------------

// AnalyzeIndexResp

// optional .tipb.Histogram hist = 1;
inline bool AnalyzeIndexResp::has_hist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AnalyzeIndexResp::set_has_hist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AnalyzeIndexResp::clear_has_hist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AnalyzeIndexResp::clear_hist() {
  if (hist_ != NULL) hist_->Clear();
  clear_has_hist();
}
inline const ::tipb::Histogram& AnalyzeIndexResp::hist() const {
  const ::tipb::Histogram* p = hist_;
  // @@protoc_insertion_point(field_get:tipb.AnalyzeIndexResp.hist)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::Histogram*>(
      &::tipb::_Histogram_default_instance_);
}
inline ::tipb::Histogram* AnalyzeIndexResp::release_hist() {
  // @@protoc_insertion_point(field_release:tipb.AnalyzeIndexResp.hist)
  clear_has_hist();
  ::tipb::Histogram* temp = hist_;
  hist_ = NULL;
  return temp;
}
inline ::tipb::Histogram* AnalyzeIndexResp::mutable_hist() {
  set_has_hist();
  if (hist_ == NULL) {
    hist_ = new ::tipb::Histogram;
  }
  // @@protoc_insertion_point(field_mutable:tipb.AnalyzeIndexResp.hist)
  return hist_;
}
inline void AnalyzeIndexResp::set_allocated_hist(::tipb::Histogram* hist) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete hist_;
  }
  if (hist) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      hist = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hist, submessage_arena);
    }
    set_has_hist();
  } else {
    clear_has_hist();
  }
  hist_ = hist;
  // @@protoc_insertion_point(field_set_allocated:tipb.AnalyzeIndexResp.hist)
}

// optional .tipb.CMSketch cms = 2;
inline bool AnalyzeIndexResp::has_cms() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AnalyzeIndexResp::set_has_cms() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AnalyzeIndexResp::clear_has_cms() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AnalyzeIndexResp::clear_cms() {
  if (cms_ != NULL) cms_->Clear();
  clear_has_cms();
}
inline const ::tipb::CMSketch& AnalyzeIndexResp::cms() const {
  const ::tipb::CMSketch* p = cms_;
  // @@protoc_insertion_point(field_get:tipb.AnalyzeIndexResp.cms)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::CMSketch*>(
      &::tipb::_CMSketch_default_instance_);
}
inline ::tipb::CMSketch* AnalyzeIndexResp::release_cms() {
  // @@protoc_insertion_point(field_release:tipb.AnalyzeIndexResp.cms)
  clear_has_cms();
  ::tipb::CMSketch* temp = cms_;
  cms_ = NULL;
  return temp;
}
inline ::tipb::CMSketch* AnalyzeIndexResp::mutable_cms() {
  set_has_cms();
  if (cms_ == NULL) {
    cms_ = new ::tipb::CMSketch;
  }
  // @@protoc_insertion_point(field_mutable:tipb.AnalyzeIndexResp.cms)
  return cms_;
}
inline void AnalyzeIndexResp::set_allocated_cms(::tipb::CMSketch* cms) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cms_;
  }
  if (cms) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cms = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cms, submessage_arena);
    }
    set_has_cms();
  } else {
    clear_has_cms();
  }
  cms_ = cms;
  // @@protoc_insertion_point(field_set_allocated:tipb.AnalyzeIndexResp.cms)
}

// -------------------------------------------------------------------

// Bucket

// optional int64 count = 1;
inline bool Bucket::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Bucket::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Bucket::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Bucket::clear_count() {
  count_ = GOOGLE_LONGLONG(0);
  clear_has_count();
}
inline ::google::protobuf::int64 Bucket::count() const {
  // @@protoc_insertion_point(field_get:tipb.Bucket.count)
  return count_;
}
inline void Bucket::set_count(::google::protobuf::int64 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:tipb.Bucket.count)
}

// optional bytes lower_bound = 2;
inline bool Bucket::has_lower_bound() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bucket::set_has_lower_bound() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bucket::clear_has_lower_bound() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bucket::clear_lower_bound() {
  lower_bound_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lower_bound();
}
inline const ::std::string& Bucket::lower_bound() const {
  // @@protoc_insertion_point(field_get:tipb.Bucket.lower_bound)
  return lower_bound_.GetNoArena();
}
inline void Bucket::set_lower_bound(const ::std::string& value) {
  set_has_lower_bound();
  lower_bound_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tipb.Bucket.lower_bound)
}
#if LANG_CXX11
inline void Bucket::set_lower_bound(::std::string&& value) {
  set_has_lower_bound();
  lower_bound_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tipb.Bucket.lower_bound)
}
#endif
inline void Bucket::set_lower_bound(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lower_bound();
  lower_bound_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tipb.Bucket.lower_bound)
}
inline void Bucket::set_lower_bound(const void* value, size_t size) {
  set_has_lower_bound();
  lower_bound_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tipb.Bucket.lower_bound)
}
inline ::std::string* Bucket::mutable_lower_bound() {
  set_has_lower_bound();
  // @@protoc_insertion_point(field_mutable:tipb.Bucket.lower_bound)
  return lower_bound_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Bucket::release_lower_bound() {
  // @@protoc_insertion_point(field_release:tipb.Bucket.lower_bound)
  clear_has_lower_bound();
  return lower_bound_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Bucket::set_allocated_lower_bound(::std::string* lower_bound) {
  if (lower_bound != NULL) {
    set_has_lower_bound();
  } else {
    clear_has_lower_bound();
  }
  lower_bound_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lower_bound);
  // @@protoc_insertion_point(field_set_allocated:tipb.Bucket.lower_bound)
}

// optional bytes upper_bound = 3;
inline bool Bucket::has_upper_bound() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Bucket::set_has_upper_bound() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Bucket::clear_has_upper_bound() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Bucket::clear_upper_bound() {
  upper_bound_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_upper_bound();
}
inline const ::std::string& Bucket::upper_bound() const {
  // @@protoc_insertion_point(field_get:tipb.Bucket.upper_bound)
  return upper_bound_.GetNoArena();
}
inline void Bucket::set_upper_bound(const ::std::string& value) {
  set_has_upper_bound();
  upper_bound_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tipb.Bucket.upper_bound)
}
#if LANG_CXX11
inline void Bucket::set_upper_bound(::std::string&& value) {
  set_has_upper_bound();
  upper_bound_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tipb.Bucket.upper_bound)
}
#endif
inline void Bucket::set_upper_bound(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_upper_bound();
  upper_bound_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tipb.Bucket.upper_bound)
}
inline void Bucket::set_upper_bound(const void* value, size_t size) {
  set_has_upper_bound();
  upper_bound_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tipb.Bucket.upper_bound)
}
inline ::std::string* Bucket::mutable_upper_bound() {
  set_has_upper_bound();
  // @@protoc_insertion_point(field_mutable:tipb.Bucket.upper_bound)
  return upper_bound_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Bucket::release_upper_bound() {
  // @@protoc_insertion_point(field_release:tipb.Bucket.upper_bound)
  clear_has_upper_bound();
  return upper_bound_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Bucket::set_allocated_upper_bound(::std::string* upper_bound) {
  if (upper_bound != NULL) {
    set_has_upper_bound();
  } else {
    clear_has_upper_bound();
  }
  upper_bound_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), upper_bound);
  // @@protoc_insertion_point(field_set_allocated:tipb.Bucket.upper_bound)
}

// optional int64 repeats = 4;
inline bool Bucket::has_repeats() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Bucket::set_has_repeats() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Bucket::clear_has_repeats() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Bucket::clear_repeats() {
  repeats_ = GOOGLE_LONGLONG(0);
  clear_has_repeats();
}
inline ::google::protobuf::int64 Bucket::repeats() const {
  // @@protoc_insertion_point(field_get:tipb.Bucket.repeats)
  return repeats_;
}
inline void Bucket::set_repeats(::google::protobuf::int64 value) {
  set_has_repeats();
  repeats_ = value;
  // @@protoc_insertion_point(field_set:tipb.Bucket.repeats)
}

// -------------------------------------------------------------------

// Histogram

// optional int64 ndv = 1;
inline bool Histogram::has_ndv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Histogram::set_has_ndv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Histogram::clear_has_ndv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Histogram::clear_ndv() {
  ndv_ = GOOGLE_LONGLONG(0);
  clear_has_ndv();
}
inline ::google::protobuf::int64 Histogram::ndv() const {
  // @@protoc_insertion_point(field_get:tipb.Histogram.ndv)
  return ndv_;
}
inline void Histogram::set_ndv(::google::protobuf::int64 value) {
  set_has_ndv();
  ndv_ = value;
  // @@protoc_insertion_point(field_set:tipb.Histogram.ndv)
}

// repeated .tipb.Bucket buckets = 2;
inline int Histogram::buckets_size() const {
  return buckets_.size();
}
inline void Histogram::clear_buckets() {
  buckets_.Clear();
}
inline const ::tipb::Bucket& Histogram::buckets(int index) const {
  // @@protoc_insertion_point(field_get:tipb.Histogram.buckets)
  return buckets_.Get(index);
}
inline ::tipb::Bucket* Histogram::mutable_buckets(int index) {
  // @@protoc_insertion_point(field_mutable:tipb.Histogram.buckets)
  return buckets_.Mutable(index);
}
inline ::tipb::Bucket* Histogram::add_buckets() {
  // @@protoc_insertion_point(field_add:tipb.Histogram.buckets)
  return buckets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tipb::Bucket >*
Histogram::mutable_buckets() {
  // @@protoc_insertion_point(field_mutable_list:tipb.Histogram.buckets)
  return &buckets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tipb::Bucket >&
Histogram::buckets() const {
  // @@protoc_insertion_point(field_list:tipb.Histogram.buckets)
  return buckets_;
}

// -------------------------------------------------------------------

// FMSketch

// optional uint64 mask = 1;
inline bool FMSketch::has_mask() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FMSketch::set_has_mask() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FMSketch::clear_has_mask() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FMSketch::clear_mask() {
  mask_ = GOOGLE_ULONGLONG(0);
  clear_has_mask();
}
inline ::google::protobuf::uint64 FMSketch::mask() const {
  // @@protoc_insertion_point(field_get:tipb.FMSketch.mask)
  return mask_;
}
inline void FMSketch::set_mask(::google::protobuf::uint64 value) {
  set_has_mask();
  mask_ = value;
  // @@protoc_insertion_point(field_set:tipb.FMSketch.mask)
}

// repeated uint64 hashset = 2;
inline int FMSketch::hashset_size() const {
  return hashset_.size();
}
inline void FMSketch::clear_hashset() {
  hashset_.Clear();
}
inline ::google::protobuf::uint64 FMSketch::hashset(int index) const {
  // @@protoc_insertion_point(field_get:tipb.FMSketch.hashset)
  return hashset_.Get(index);
}
inline void FMSketch::set_hashset(int index, ::google::protobuf::uint64 value) {
  hashset_.Set(index, value);
  // @@protoc_insertion_point(field_set:tipb.FMSketch.hashset)
}
inline void FMSketch::add_hashset(::google::protobuf::uint64 value) {
  hashset_.Add(value);
  // @@protoc_insertion_point(field_add:tipb.FMSketch.hashset)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
FMSketch::hashset() const {
  // @@protoc_insertion_point(field_list:tipb.FMSketch.hashset)
  return hashset_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
FMSketch::mutable_hashset() {
  // @@protoc_insertion_point(field_mutable_list:tipb.FMSketch.hashset)
  return &hashset_;
}

// -------------------------------------------------------------------

// SampleCollector

// repeated bytes samples = 1;
inline int SampleCollector::samples_size() const {
  return samples_.size();
}
inline void SampleCollector::clear_samples() {
  samples_.Clear();
}
inline const ::std::string& SampleCollector::samples(int index) const {
  // @@protoc_insertion_point(field_get:tipb.SampleCollector.samples)
  return samples_.Get(index);
}
inline ::std::string* SampleCollector::mutable_samples(int index) {
  // @@protoc_insertion_point(field_mutable:tipb.SampleCollector.samples)
  return samples_.Mutable(index);
}
inline void SampleCollector::set_samples(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tipb.SampleCollector.samples)
  samples_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SampleCollector::set_samples(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tipb.SampleCollector.samples)
  samples_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SampleCollector::set_samples(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  samples_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tipb.SampleCollector.samples)
}
inline void SampleCollector::set_samples(int index, const void* value, size_t size) {
  samples_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tipb.SampleCollector.samples)
}
inline ::std::string* SampleCollector::add_samples() {
  // @@protoc_insertion_point(field_add_mutable:tipb.SampleCollector.samples)
  return samples_.Add();
}
inline void SampleCollector::add_samples(const ::std::string& value) {
  samples_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tipb.SampleCollector.samples)
}
#if LANG_CXX11
inline void SampleCollector::add_samples(::std::string&& value) {
  samples_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tipb.SampleCollector.samples)
}
#endif
inline void SampleCollector::add_samples(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  samples_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tipb.SampleCollector.samples)
}
inline void SampleCollector::add_samples(const void* value, size_t size) {
  samples_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tipb.SampleCollector.samples)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SampleCollector::samples() const {
  // @@protoc_insertion_point(field_list:tipb.SampleCollector.samples)
  return samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SampleCollector::mutable_samples() {
  // @@protoc_insertion_point(field_mutable_list:tipb.SampleCollector.samples)
  return &samples_;
}

// optional int64 null_count = 2;
inline bool SampleCollector::has_null_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SampleCollector::set_has_null_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SampleCollector::clear_has_null_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SampleCollector::clear_null_count() {
  null_count_ = GOOGLE_LONGLONG(0);
  clear_has_null_count();
}
inline ::google::protobuf::int64 SampleCollector::null_count() const {
  // @@protoc_insertion_point(field_get:tipb.SampleCollector.null_count)
  return null_count_;
}
inline void SampleCollector::set_null_count(::google::protobuf::int64 value) {
  set_has_null_count();
  null_count_ = value;
  // @@protoc_insertion_point(field_set:tipb.SampleCollector.null_count)
}

// optional int64 count = 3;
inline bool SampleCollector::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SampleCollector::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SampleCollector::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SampleCollector::clear_count() {
  count_ = GOOGLE_LONGLONG(0);
  clear_has_count();
}
inline ::google::protobuf::int64 SampleCollector::count() const {
  // @@protoc_insertion_point(field_get:tipb.SampleCollector.count)
  return count_;
}
inline void SampleCollector::set_count(::google::protobuf::int64 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:tipb.SampleCollector.count)
}

// optional .tipb.FMSketch fm_sketch = 4;
inline bool SampleCollector::has_fm_sketch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SampleCollector::set_has_fm_sketch() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SampleCollector::clear_has_fm_sketch() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SampleCollector::clear_fm_sketch() {
  if (fm_sketch_ != NULL) fm_sketch_->Clear();
  clear_has_fm_sketch();
}
inline const ::tipb::FMSketch& SampleCollector::fm_sketch() const {
  const ::tipb::FMSketch* p = fm_sketch_;
  // @@protoc_insertion_point(field_get:tipb.SampleCollector.fm_sketch)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::FMSketch*>(
      &::tipb::_FMSketch_default_instance_);
}
inline ::tipb::FMSketch* SampleCollector::release_fm_sketch() {
  // @@protoc_insertion_point(field_release:tipb.SampleCollector.fm_sketch)
  clear_has_fm_sketch();
  ::tipb::FMSketch* temp = fm_sketch_;
  fm_sketch_ = NULL;
  return temp;
}
inline ::tipb::FMSketch* SampleCollector::mutable_fm_sketch() {
  set_has_fm_sketch();
  if (fm_sketch_ == NULL) {
    fm_sketch_ = new ::tipb::FMSketch;
  }
  // @@protoc_insertion_point(field_mutable:tipb.SampleCollector.fm_sketch)
  return fm_sketch_;
}
inline void SampleCollector::set_allocated_fm_sketch(::tipb::FMSketch* fm_sketch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fm_sketch_;
  }
  if (fm_sketch) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fm_sketch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fm_sketch, submessage_arena);
    }
    set_has_fm_sketch();
  } else {
    clear_has_fm_sketch();
  }
  fm_sketch_ = fm_sketch;
  // @@protoc_insertion_point(field_set_allocated:tipb.SampleCollector.fm_sketch)
}

// optional .tipb.CMSketch cm_sketch = 5;
inline bool SampleCollector::has_cm_sketch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SampleCollector::set_has_cm_sketch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SampleCollector::clear_has_cm_sketch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SampleCollector::clear_cm_sketch() {
  if (cm_sketch_ != NULL) cm_sketch_->Clear();
  clear_has_cm_sketch();
}
inline const ::tipb::CMSketch& SampleCollector::cm_sketch() const {
  const ::tipb::CMSketch* p = cm_sketch_;
  // @@protoc_insertion_point(field_get:tipb.SampleCollector.cm_sketch)
  return p != NULL ? *p : *reinterpret_cast<const ::tipb::CMSketch*>(
      &::tipb::_CMSketch_default_instance_);
}
inline ::tipb::CMSketch* SampleCollector::release_cm_sketch() {
  // @@protoc_insertion_point(field_release:tipb.SampleCollector.cm_sketch)
  clear_has_cm_sketch();
  ::tipb::CMSketch* temp = cm_sketch_;
  cm_sketch_ = NULL;
  return temp;
}
inline ::tipb::CMSketch* SampleCollector::mutable_cm_sketch() {
  set_has_cm_sketch();
  if (cm_sketch_ == NULL) {
    cm_sketch_ = new ::tipb::CMSketch;
  }
  // @@protoc_insertion_point(field_mutable:tipb.SampleCollector.cm_sketch)
  return cm_sketch_;
}
inline void SampleCollector::set_allocated_cm_sketch(::tipb::CMSketch* cm_sketch) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cm_sketch_;
  }
  if (cm_sketch) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cm_sketch = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cm_sketch, submessage_arena);
    }
    set_has_cm_sketch();
  } else {
    clear_has_cm_sketch();
  }
  cm_sketch_ = cm_sketch;
  // @@protoc_insertion_point(field_set_allocated:tipb.SampleCollector.cm_sketch)
}

// optional int64 total_size = 6;
inline bool SampleCollector::has_total_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SampleCollector::set_has_total_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SampleCollector::clear_has_total_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SampleCollector::clear_total_size() {
  total_size_ = GOOGLE_LONGLONG(0);
  clear_has_total_size();
}
inline ::google::protobuf::int64 SampleCollector::total_size() const {
  // @@protoc_insertion_point(field_get:tipb.SampleCollector.total_size)
  return total_size_;
}
inline void SampleCollector::set_total_size(::google::protobuf::int64 value) {
  set_has_total_size();
  total_size_ = value;
  // @@protoc_insertion_point(field_set:tipb.SampleCollector.total_size)
}

// -------------------------------------------------------------------

// CMSketchRow

// repeated uint32 counters = 1;
inline int CMSketchRow::counters_size() const {
  return counters_.size();
}
inline void CMSketchRow::clear_counters() {
  counters_.Clear();
}
inline ::google::protobuf::uint32 CMSketchRow::counters(int index) const {
  // @@protoc_insertion_point(field_get:tipb.CMSketchRow.counters)
  return counters_.Get(index);
}
inline void CMSketchRow::set_counters(int index, ::google::protobuf::uint32 value) {
  counters_.Set(index, value);
  // @@protoc_insertion_point(field_set:tipb.CMSketchRow.counters)
}
inline void CMSketchRow::add_counters(::google::protobuf::uint32 value) {
  counters_.Add(value);
  // @@protoc_insertion_point(field_add:tipb.CMSketchRow.counters)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
CMSketchRow::counters() const {
  // @@protoc_insertion_point(field_list:tipb.CMSketchRow.counters)
  return counters_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
CMSketchRow::mutable_counters() {
  // @@protoc_insertion_point(field_mutable_list:tipb.CMSketchRow.counters)
  return &counters_;
}

// -------------------------------------------------------------------

// CMSketchTopN

// optional bytes data = 1;
inline bool CMSketchTopN::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMSketchTopN::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMSketchTopN::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMSketchTopN::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& CMSketchTopN::data() const {
  // @@protoc_insertion_point(field_get:tipb.CMSketchTopN.data)
  return data_.GetNoArena();
}
inline void CMSketchTopN::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tipb.CMSketchTopN.data)
}
#if LANG_CXX11
inline void CMSketchTopN::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tipb.CMSketchTopN.data)
}
#endif
inline void CMSketchTopN::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tipb.CMSketchTopN.data)
}
inline void CMSketchTopN::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tipb.CMSketchTopN.data)
}
inline ::std::string* CMSketchTopN::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:tipb.CMSketchTopN.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CMSketchTopN::release_data() {
  // @@protoc_insertion_point(field_release:tipb.CMSketchTopN.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CMSketchTopN::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:tipb.CMSketchTopN.data)
}

// optional uint64 count = 2;
inline bool CMSketchTopN::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMSketchTopN::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMSketchTopN::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMSketchTopN::clear_count() {
  count_ = GOOGLE_ULONGLONG(0);
  clear_has_count();
}
inline ::google::protobuf::uint64 CMSketchTopN::count() const {
  // @@protoc_insertion_point(field_get:tipb.CMSketchTopN.count)
  return count_;
}
inline void CMSketchTopN::set_count(::google::protobuf::uint64 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:tipb.CMSketchTopN.count)
}

// -------------------------------------------------------------------

// CMSketch

// repeated .tipb.CMSketchRow rows = 1;
inline int CMSketch::rows_size() const {
  return rows_.size();
}
inline void CMSketch::clear_rows() {
  rows_.Clear();
}
inline const ::tipb::CMSketchRow& CMSketch::rows(int index) const {
  // @@protoc_insertion_point(field_get:tipb.CMSketch.rows)
  return rows_.Get(index);
}
inline ::tipb::CMSketchRow* CMSketch::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:tipb.CMSketch.rows)
  return rows_.Mutable(index);
}
inline ::tipb::CMSketchRow* CMSketch::add_rows() {
  // @@protoc_insertion_point(field_add:tipb.CMSketch.rows)
  return rows_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tipb::CMSketchRow >*
CMSketch::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:tipb.CMSketch.rows)
  return &rows_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tipb::CMSketchRow >&
CMSketch::rows() const {
  // @@protoc_insertion_point(field_list:tipb.CMSketch.rows)
  return rows_;
}

// repeated .tipb.CMSketchTopN top_n = 2;
inline int CMSketch::top_n_size() const {
  return top_n_.size();
}
inline void CMSketch::clear_top_n() {
  top_n_.Clear();
}
inline const ::tipb::CMSketchTopN& CMSketch::top_n(int index) const {
  // @@protoc_insertion_point(field_get:tipb.CMSketch.top_n)
  return top_n_.Get(index);
}
inline ::tipb::CMSketchTopN* CMSketch::mutable_top_n(int index) {
  // @@protoc_insertion_point(field_mutable:tipb.CMSketch.top_n)
  return top_n_.Mutable(index);
}
inline ::tipb::CMSketchTopN* CMSketch::add_top_n() {
  // @@protoc_insertion_point(field_add:tipb.CMSketch.top_n)
  return top_n_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tipb::CMSketchTopN >*
CMSketch::mutable_top_n() {
  // @@protoc_insertion_point(field_mutable_list:tipb.CMSketch.top_n)
  return &top_n_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tipb::CMSketchTopN >&
CMSketch::top_n() const {
  // @@protoc_insertion_point(field_list:tipb.CMSketch.top_n)
  return top_n_;
}

// optional uint64 default_value = 3;
inline bool CMSketch::has_default_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMSketch::set_has_default_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMSketch::clear_has_default_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMSketch::clear_default_value() {
  default_value_ = GOOGLE_ULONGLONG(0);
  clear_has_default_value();
}
inline ::google::protobuf::uint64 CMSketch::default_value() const {
  // @@protoc_insertion_point(field_get:tipb.CMSketch.default_value)
  return default_value_;
}
inline void CMSketch::set_default_value(::google::protobuf::uint64 value) {
  set_has_default_value();
  default_value_ = value;
  // @@protoc_insertion_point(field_set:tipb.CMSketch.default_value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tipb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tipb::AnalyzeType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tipb::AnalyzeType>() {
  return ::tipb::AnalyzeType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_analyze_2eproto__INCLUDED
